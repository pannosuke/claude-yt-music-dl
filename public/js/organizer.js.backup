/**
 * Music Library Organizer Module
 * Organizes music files for optimal Plex Media Server compatibility
 */

// Module state
let scanData = null;
let structureData = null; // Structure scan results
let selectedGroups = new Set();
let currentScanController = null;

// Plex integration state
let plexConnectionData = null; // { serverIp, port, token }
let plexLibraries = null;
let selectedLibraryId = null;
let plexTracks = null;
let comparisonResults = null;
let currentFilterCategory = 'all';

// Three-phase matching state
let artistMatchResults = null;
let albumMatchResults = null;

// DOM elements
const organizerElements = {
    form: null,
    scanBtn: null,
    cancelScanBtn: null,
    deepScanSelectedBtn: null,
    deepScanAllBtn: null,
    musicPathInput: null,
    progressContainer: null,
    progressBar: null,
    progressText: null,
    logContainer: null,
    resultsContainer: null,
    newScanBtn: null,
    summaryTotalFiles: null,
    summaryCompliantFiles: null,
    summaryNeedsFix: null,
    summaryArtists: null,
    summaryAlbums: null,
    issuesBreakdown: null,
    issuesListEl: null,
    formatList: null,
    groupGrid: null
};

/**
 * Initialize the organizer module
 */
function initOrganizer() {
    // Cache DOM elements
    organizerElements.form = document.getElementById('scanForm');
    organizerElements.scanBtn = document.getElementById('scanBtn');
    organizerElements.cancelScanBtn = document.getElementById('cancelScanBtn');
    organizerElements.musicPathInput = document.getElementById('musicPath');
    organizerElements.progressContainer = document.getElementById('scanProgressContainer');
    organizerElements.progressBar = document.getElementById('scanProgressBar');
    organizerElements.progressText = document.getElementById('scanProgressText');
    organizerElements.logContainer = document.getElementById('scanLogContainer');
    organizerElements.resultsContainer = document.getElementById('scanResults');
    organizerElements.newScanBtn = document.getElementById('newScanBtn');
    organizerElements.summaryTotalFiles = document.getElementById('summaryTotalFiles');
    organizerElements.summaryCompliantFiles = document.getElementById('summaryCompliantFiles');
    organizerElements.summaryNeedsFix = document.getElementById('summaryNeedsFix');
    organizerElements.summaryArtists = document.getElementById('summaryArtists');
    organizerElements.summaryAlbums = document.getElementById('summaryAlbums');
    organizerElements.issuesBreakdown = document.getElementById('issuesBreakdown');
    organizerElements.issuesListEl = document.getElementById('issuesList');
    organizerElements.formatList = document.getElementById('formatList');
    organizerElements.groupGrid = document.getElementById('groupGrid');
    organizerElements.deepScanSelectedBtn = document.getElementById('deepScanSelectedBtn');
    organizerElements.deepScanAllBtn = document.getElementById('deepScanAllBtn');

    // Load saved settings
    loadSavedPath();
    loadSavedStagingPath();

    // Setup event listeners
    organizerElements.form.addEventListener('submit', handleScanSubmit);
    organizerElements.newScanBtn.addEventListener('click', resetScan);
    organizerElements.cancelScanBtn.addEventListener('click', handleCancelScan);
    organizerElements.deepScanSelectedBtn.addEventListener('click', () => handleDeepScan(false));
    organizerElements.deepScanAllBtn.addEventListener('click', () => handleDeepScan(true));

    // Add drag and drop support for folders
    setupDragAndDrop();

    // Setup modal event listeners for Phase 3.75
    setupModalEventListeners();

    // Show the module
    const module = document.getElementById('module-organizer');
    if (module) {
        module.classList.add('active');
    }
}

/**
 * Load saved music path from localStorage
 */
function loadSavedPath() {
    const savedPath = localStorage.getItem('musicPath');
    if (savedPath && organizerElements.musicPathInput) {
        organizerElements.musicPathInput.value = savedPath;
    }
}

/**
 * Save music path to localStorage
 */
function savePath(musicPath) {
    localStorage.setItem('musicPath', musicPath);
}

/**
 * Load saved staging path from localStorage
 */
function loadSavedStagingPath() {
    const savedStagingPath = localStorage.getItem('stagingPath');
    const stagingPathInput = document.getElementById('stagingPathInput');
    if (savedStagingPath && stagingPathInput) {
        stagingPathInput.value = savedStagingPath;
    }
}

/**
 * Save staging path to localStorage
 */
function saveStagingPath(stagingPath) {
    localStorage.setItem('stagingPath', stagingPath);
}

/**
 * Smooth scroll element into view at the top of the viewport
 * @param {HTMLElement|String} element - Element or selector to scroll to
 */
function scrollToElement(element) {
    const selector = typeof element === 'string' ? element : (element?.id ? `#${element.id}` : element?.className ? `.${element.className}` : 'unknown');
    console.log('[Scroll] Attempting to scroll to:', selector);

    const el = typeof element === 'string' ? document.querySelector(element) : element;
    if (el) {
        console.log('[Scroll] Element found:', el);
        console.log('[Scroll] Element visibility - display:', window.getComputedStyle(el).display, 'visibility:', window.getComputedStyle(el).visibility);
        console.log('[Scroll] Element position - top:', el.getBoundingClientRect().top, 'height:', el.offsetHeight);

        // Use requestAnimationFrame to ensure DOM has been painted
        requestAnimationFrame(() => {
            console.log('[Scroll] Executing scroll...');
            el.scrollIntoView({ behavior: 'smooth', block: 'start', inline: 'nearest' });

            // Fallback: Also scroll window to element position minus offset
            const yOffset = -20; // 20px from top
            const y = el.getBoundingClientRect().top + window.pageYOffset + yOffset;
            window.scrollTo({ top: y, behavior: 'smooth' });
        });
    } else {
        console.warn('[Scroll] Element not found:', selector);
    }
}

/**
 * Add a log entry
 */
function addScanLog(message, type = 'info') {
    const logEntry = document.createElement('div');
    logEntry.className = `log-entry ${type}`;
    const timestamp = new Date().toLocaleTimeString('en-US', { hour12: false, hour: '2-digit', minute: '2-digit', second: '2-digit' });
    logEntry.textContent = `[${timestamp}] ${message}`;
    organizerElements.logContainer.appendChild(logEntry);
    organizerElements.logContainer.scrollTop = organizerElements.logContainer.scrollHeight;
    console.log(`[${type.toUpperCase()}] ${message}`);
}

/**
 * Update scan progress
 */
function updateScanProgress(percent, text) {
    organizerElements.progressBar.style.width = percent + '%';
    organizerElements.progressText.textContent = text;
}

/**
 * Reset scan form for new scan
 */
function resetScan() {
    // Cancel any ongoing scan
    if (currentScanController) {
        currentScanController.abort();
        currentScanController = null;
    }

    // Hide results
    organizerElements.resultsContainer.classList.remove('active');

    // Show form
    organizerElements.form.style.display = 'block';

    // Reset state
    scanData = null;
    selectedGroups.clear();

    // Re-enable scan button
    organizerElements.scanBtn.disabled = false;
    organizerElements.scanBtn.textContent = 'Scan Library';

    // Hide cancel button
    organizerElements.cancelScanBtn.style.display = 'none';

    // Clear progress
    organizerElements.progressContainer.style.display = 'none';
    organizerElements.logContainer.innerHTML = '';
}

/**
 * Handle scan cancellation
 */
function handleCancelScan() {
    if (currentScanController) {
        addScanLog('Cancelling scan...', 'warning');
        currentScanController.abort();
        currentScanController = null;

        // Reset UI
        organizerElements.scanBtn.disabled = false;
        organizerElements.scanBtn.textContent = 'Scan Library';
        organizerElements.cancelScanBtn.style.display = 'none';
        updateScanProgress(100, 'Scan cancelled by user');
    }
}

/**
 * Display structure scan results (Phase 1)
 */
function displayStructureResults(structure) {
    // Update summary cards with structure data
    organizerElements.summaryTotalFiles.textContent = '--';
    organizerElements.summaryCompliantFiles.textContent = '--';
    organizerElements.summaryNeedsFix.textContent = structure.totalLooseFiles || 0;
    organizerElements.summaryArtists.textContent = structure.totalArtists;
    organizerElements.summaryAlbums.textContent = structure.totalAlbums;

    // Hide issues breakdown for structure scan
    organizerElements.issuesBreakdown.style.display = 'none';

    // Hide format list for structure scan
    organizerElements.formatList.innerHTML = '<span class="format-badge">Structure Scan - No file metadata</span>';

    // Display alphabetical groups with enhanced info
    displayStructureGroups(structure.groupedByLetter);

    // Show results section
    organizerElements.resultsContainer.classList.add('active');

    // Hide form
    organizerElements.form.style.display = 'none';
}

/**
 * Display deep scan results (Phase 2)
 */
function displayScanResults(data) {
    // Extract files array from groupedByArtist structure
    const allFiles = [];
    if (data.groupedByArtist) {
        for (const letter in data.groupedByArtist) {
            const group = data.groupedByArtist[letter];
            if (group.files && Array.isArray(group.files)) {
                allFiles.push(...group.files);
            }
        }
    }

    // Add files array to scanData for batch match
    scanData = {
        ...data,
        files: allFiles
    };

    // Update summary cards
    organizerElements.summaryTotalFiles.textContent = data.summary.totalFiles;
    organizerElements.summaryCompliantFiles.textContent = data.summary.compliantFiles;
    organizerElements.summaryNeedsFix.textContent = data.summary.filesNeedingReorganization;
    organizerElements.summaryArtists.textContent = data.summary.artistCount;
    organizerElements.summaryAlbums.textContent = data.summary.albumCount;

    // Display issues breakdown if there are issues
    if (Object.keys(data.summary.issuesByType).length > 0) {
        organizerElements.issuesBreakdown.style.display = 'block';

        let issuesHTML = '';
        for (const [type, count] of Object.entries(data.summary.issuesByType)) {
            const typeName = type.replace(/_/g, ' ').replace(/\b\w/g, l => l.toUpperCase());
            issuesHTML += `
                <div class="issue-type">
                    <span class="type-name">${typeName}</span>
                    <span class="count">${count}</span>
                </div>
            `;
        }
        organizerElements.issuesListEl.innerHTML = issuesHTML;
    }

    // Display format distribution
    if (Object.keys(data.summary.formats).length > 0) {
        let formatsHTML = '';
        for (const [format, count] of Object.entries(data.summary.formats)) {
            formatsHTML += `<span class="format-badge">${format} (${count})</span>`;
        }
        organizerElements.formatList.innerHTML = formatsHTML;
    }

    // Display alphabetical groups
    displayArtistGroups(data.groupedByArtist);

    // Show results section
    organizerElements.resultsContainer.classList.add('active');

    // Hide form
    organizerElements.form.style.display = 'none';

    // Scroll to scan results (increased delay for DOM to update)
    setTimeout(() => scrollToElement(organizerElements.resultsContainer), 300);
}

/**
 * Display structure groups (alphabetical) with selection capability
 */
function displayStructureGroups(groupedByLetter) {
    let groupsHTML = '';

    // Sort by letter
    const sortedLetters = Object.keys(groupedByLetter).sort();

    for (const letter of sortedLetters) {
        const group = groupedByLetter[letter];
        const looseInfo = group.looseFileCount > 0 ? `<br>${group.looseFileCount} loose file${group.looseFileCount !== 1 ? 's' : ''}` : '';
        groupsHTML += `
            <div class="group-card" data-letter="${letter}">
                <div class="letter">${letter}</div>
                <div class="stats">
                    ${group.artistCount} artist${group.artistCount !== 1 ? 's' : ''}<br>
                    ${group.albumCount} album${group.albumCount !== 1 ? 's' : ''}${looseInfo}
                </div>
            </div>
        `;
    }

    organizerElements.groupGrid.innerHTML = groupsHTML;

    // Add click handlers to group cards for selection
    const groupCards = organizerElements.groupGrid.querySelectorAll('.group-card');
    groupCards.forEach(card => {
        card.addEventListener('click', () => {
            const letter = card.getAttribute('data-letter');
            if (selectedGroups.has(letter)) {
                selectedGroups.delete(letter);
                card.classList.remove('selected');
            } else {
                selectedGroups.add(letter);
                card.classList.add('selected');
            }
            updateDeepScanButtons();
        });
    });

    // Show deep scan buttons
    updateDeepScanButtons();
}

/**
 * Display artist groups (alphabetical) - deep scan results
 * Now includes expandable file lists with metadata
 */
function displayArtistGroups(groupedByArtist) {
    let groupsHTML = '';

    // Sort by letter
    const sortedLetters = Object.keys(groupedByArtist).sort();

    for (const letter of sortedLetters) {
        const group = groupedByArtist[letter];
        const artistsList = Array.from(group.artists).sort();

        groupsHTML += `
            <div class="group-card expandable" data-letter="${letter}">
                <div class="letter">${letter}</div>
                <div class="stats">
                    ${group.artistCount} artist${group.artistCount !== 1 ? 's' : ''}<br>
                    ${group.fileCount} file${group.fileCount !== 1 ? 's' : ''}
                </div>
            </div>
        `;
    }

    organizerElements.groupGrid.innerHTML = groupsHTML;

    // Add click handlers to expand/collapse groups
    const groupCards = organizerElements.groupGrid.querySelectorAll('.group-card');
    groupCards.forEach(card => {
        card.addEventListener('click', () => toggleArtistGroup(card));
    });
}

/**
 * Toggle artist group expansion to show file details
 */
function toggleArtistGroup(card) {
    const letter = card.getAttribute('data-letter');

    // Check if already expanded
    const existingDetails = card.nextElementSibling;
    if (existingDetails && existingDetails.classList.contains('group-details')) {
        // Collapse
        existingDetails.remove();
        card.classList.remove('expanded');
        return;
    }

    // Expand - show file details
    if (!scanData || !scanData.groupedByArtist || !scanData.groupedByArtist[letter]) {
        return;
    }

    const group = scanData.groupedByArtist[letter];
    const artists = Array.from(group.artists).sort();

    let detailsHTML = '<div class="group-details">';

    // Show each artist's files
    for (const artist of artists) {
        const artistFiles = group.files.filter(f => {
            const fileArtist = f.metadata.artist || f.metadata.albumArtist || f.folderArtist || 'Unknown';
            return fileArtist === artist;
        });

        if (artistFiles.length === 0) continue;

        detailsHTML += `
            <div class="artist-section">
                <h4 class="artist-name">${artist} (${artistFiles.length} file${artistFiles.length !== 1 ? 's' : ''})</h4>
                <div class="file-list">
        `;

        for (const file of artistFiles) {
            const fileName = file.fileName;
            const album = file.metadata.album || 'Unknown Album';
            const title = file.metadata.title || fileName;
            const format = file.metadata.format || 'Unknown';
            const isCompliant = file.compliance.isCompliant;
            const issuesCount = file.compliance.issues.length;

            detailsHTML += `
                <div class="file-item ${isCompliant ? 'compliant' : 'needs-fix'}">
                    <div class="file-info">
                        <div class="file-title">${title}</div>
                        <div class="file-meta">
                            <span class="format-badge">${format}</span>
                            <span class="album-name">${album}</span>
                        </div>
                    </div>
                    <div class="file-status">
                        ${isCompliant ?
                            '<span class="status-badge compliant">✓ Compliant</span>' :
                            `<span class="status-badge needs-fix">⚠ ${issuesCount} issue${issuesCount !== 1 ? 's' : ''}</span>`
                        }
                    </div>
                </div>
            `;
        }

        detailsHTML += `
                </div>
            </div>
        `;
    }

    detailsHTML += '</div>';

    // Insert after the card
    card.insertAdjacentHTML('afterend', detailsHTML);
    card.classList.add('expanded');
}

/**
 * Update deep scan button visibility and state
 */
function updateDeepScanButtons() {
    if (!organizerElements.deepScanSelectedBtn || !organizerElements.deepScanAllBtn) {
        return;
    }

    // Show the button container
    const buttonContainer = document.getElementById('deepScanButtons');
    if (buttonContainer) {
        buttonContainer.style.display = 'block';
    }

    if (selectedGroups.size > 0) {
        organizerElements.deepScanSelectedBtn.style.display = 'inline-block';
        organizerElements.deepScanSelectedBtn.textContent = `Deep Scan Selected (${selectedGroups.size})`;
    } else {
        organizerElements.deepScanSelectedBtn.style.display = 'none';
    }

    organizerElements.deepScanAllBtn.style.display = 'inline-block';
}

/**
 * Handle deep scan (selected letters or all)
 */
async function handleDeepScan(scanAll = false) {
    const musicPath = organizerElements.musicPathInput.value.trim();
    const letters = scanAll ? null : Array.from(selectedGroups);

    if (!scanAll && letters.length === 0) {
        addScanLog('Please select at least one letter group to scan', 'warning');
        return;
    }

    const scanType = scanAll ? 'all artists' : `selected letters (${letters.join(', ')})`;
    addScanLog(`Starting deep scan of ${scanType}...`, 'info');

    // Create AbortController for this scan
    currentScanController = new AbortController();

    // Show progress container
    organizerElements.progressContainer.style.display = 'block';
    organizerElements.logContainer.innerHTML = '';
    organizerElements.cancelScanBtn.style.display = 'inline-block';
    organizerElements.deepScanSelectedBtn.disabled = true;
    organizerElements.deepScanAllBtn.disabled = true;

    try {
        const body = { musicPath };
        if (!scanAll) {
            body.artistLetters = letters;
        }

        const response = await fetch('http://localhost:3000/api/scan', {
            method: 'POST',
            headers: { 'Content-Type': 'application/json' },
            body: JSON.stringify(body),
            signal: currentScanController.signal
        });

        const reader = response.body.getReader();
        const decoder = new TextDecoder();
        let buffer = '';

        while (true) {
            const { done, value } = await reader.read();
            if (done) break;

            buffer += decoder.decode(value, { stream: true });
            const lines = buffer.split('\n');

            // Keep the last incomplete line in the buffer
            buffer = lines.pop() || '';

            for (const line of lines) {
                if (line.startsWith('data: ')) {
                    try {
                        const data = JSON.parse(line.slice(6));

                        // Update progress
                        if (data.progress !== undefined) {
                            updateScanProgress(data.progress, data.status || organizerElements.progressText.textContent);
                        }

                        // Log messages
                        if (data.status) {
                            addScanLog(data.status, 'info');
                        }
                        if (data.debug) {
                            addScanLog(data.debug, 'debug');
                        }
                        if (data.error) {
                            addScanLog(data.error, 'error');
                        }
                        if (data.warning) {
                            addScanLog(data.warning, 'warning');
                        }

                        // Log scan progress details
                        if (data.filesFound !== undefined) {
                            addScanLog(`Found ${data.filesFound} audio files`, 'info');
                        }

                        if (data.filesProcessed !== undefined && data.filesTotal !== undefined) {
                            addScanLog(`Processing ${data.filesProcessed} of ${data.filesTotal}: ${data.currentFile || ''}`, 'debug');
                        }

                        // Display results when completed
                        if (data.completed) {
                            organizerElements.cancelScanBtn.style.display = 'none';
                            organizerElements.deepScanSelectedBtn.disabled = false;
                            organizerElements.deepScanAllBtn.disabled = false;
                            currentScanController = null;

                            if (data.summary) {
                                addScanLog(`Deep scan completed! ${data.summary.totalFiles} files processed.`, 'success');
                                displayScanResults(data);
                                // Initialize Plex, MusicBrainz, and Matcher integrations after deep scan
                                initPlexIntegration();
                                initMusicBrainzIntegration();
                                initMatcherIntegration();
                            }
                        }
                    } catch (parseError) {
                        console.error('[Deep Scan] JSON parse error:', parseError);
                        console.error('[Deep Scan] Failed to parse line:', line);
                        addScanLog(`Parse error: ${parseError.message}`, 'error');
                    }
                }
            }
        }
    } catch (error) {
        if (error.name === 'AbortError') {
            addScanLog('Deep scan cancelled by user', 'warning');
        } else {
            addScanLog(`Error: ${error.message}`, 'error');
        }
        organizerElements.cancelScanBtn.style.display = 'none';
        organizerElements.deepScanSelectedBtn.disabled = false;
        organizerElements.deepScanAllBtn.disabled = false;
        currentScanController = null;
    }
}

/**
 * Setup drag and drop support for the music path input
 */
function setupDragAndDrop() {
    const input = organizerElements.musicPathInput;

    // Prevent default drag behaviors
    ['dragenter', 'dragover', 'dragleave', 'drop'].forEach(eventName => {
        input.addEventListener(eventName, preventDefaults, false);
    });

    function preventDefaults(e) {
        e.preventDefault();
        e.stopPropagation();
    }

    // Highlight input when item is dragged over it
    ['dragenter', 'dragover'].forEach(eventName => {
        input.addEventListener(eventName, () => {
            input.style.borderColor = '#667eea';
            input.style.backgroundColor = '#f0f4ff';
        }, false);
    });

    ['dragleave', 'drop'].forEach(eventName => {
        input.addEventListener(eventName, () => {
            input.style.borderColor = '#e1e8ed';
            input.style.backgroundColor = 'white';
        }, false);
    });

    // Handle dropped files/folders
    input.addEventListener('drop', (e) => {
        const dt = e.dataTransfer;
        const items = dt.items;

        if (items) {
            // Loop through items to find directories
            for (let i = 0; i < items.length; i++) {
                const item = items[i];
                if (item.kind === 'file') {
                    const entry = item.webkitGetAsEntry();
                    if (entry && entry.isDirectory) {
                        // Get the full path from the dropped item
                        // Note: entry.fullPath gives us the relative path only
                        // We need to ask the user for the full system path
                        const folderName = entry.name;

                        const fullPath = prompt(
                            `You dropped the folder: "${folderName}"\n\n` +
                            `Please enter the FULL path to this folder:\n` +
                            `(e.g., /Users/yourname/Music/${folderName} or C:\\Users\\yourname\\Music\\${folderName})`,
                            ''
                        );

                        if (fullPath) {
                            input.value = fullPath;
                            savePath(fullPath);
                        }
                        break;
                    }
                }
            }
        }
    }, false);
}

/**
 * Handle scan form submission (Phase 1: Structure Scan)
 */
async function handleScanSubmit(e) {
    e.preventDefault();

    const musicPath = organizerElements.musicPathInput.value.trim();

    // Save path to localStorage
    savePath(musicPath);

    addScanLog(`Starting structure scan of: ${musicPath}`, 'info');

    // Create AbortController for this scan
    currentScanController = new AbortController();

    // Show progress container
    organizerElements.progressContainer.style.display = 'block';
    organizerElements.logContainer.innerHTML = '';
    organizerElements.scanBtn.disabled = true;
    organizerElements.scanBtn.textContent = 'Scanning Structure...';
    organizerElements.cancelScanBtn.style.display = 'inline-block';

    try {
        const response = await fetch('http://localhost:3000/api/scan/structure', {
            method: 'POST',
            headers: { 'Content-Type': 'application/json' },
            body: JSON.stringify({ musicPath }),
            signal: currentScanController.signal
        });

        const reader = response.body.getReader();
        const decoder = new TextDecoder();

        while (true) {
            const { done, value } = await reader.read();
            if (done) break;

            const chunk = decoder.decode(value);
            const lines = chunk.split('\n');

            for (const line of lines) {
                if (line.startsWith('data: ')) {
                    const data = JSON.parse(line.slice(6));

                    // Update progress
                    if (data.progress !== undefined) {
                        updateScanProgress(data.progress, data.status || organizerElements.progressText.textContent);
                    }

                    // Log status messages
                    if (data.status) {
                        addScanLog(data.status, 'info');
                    }

                    if (data.debug) {
                        addScanLog(data.debug, 'debug');
                    }

                    if (data.error) {
                        addScanLog(data.error, 'error');
                    }

                    if (data.warning) {
                        addScanLog(data.warning, 'warning');
                    }

                    // Log scan progress details
                    if (data.filesFound !== undefined) {
                        addScanLog(`Found ${data.filesFound} audio files`, 'info');
                    }

                    if (data.filesProcessed !== undefined && data.filesTotal !== undefined) {
                        addScanLog(`Processing ${data.filesProcessed} of ${data.filesTotal}: ${data.currentFile || ''}`, 'debug');
                    }

                    // Display results when completed
                    if (data.completed) {
                        organizerElements.scanBtn.disabled = false;
                        organizerElements.scanBtn.textContent = 'Scan Library';
                        organizerElements.cancelScanBtn.style.display = 'none';
                        currentScanController = null;

                        if (data.structure) {
                            // Structure scan completed
                            addScanLog(`Structure scan completed! Found ${data.structure.totalArtists} artists.`, 'success');
                            structureData = data.structure;
                            displayStructureResults(data.structure);
                        } else if (data.summary) {
                            // Deep scan completed
                            addScanLog(`Deep scan completed! ${data.summary.totalFiles} files processed.`, 'success');
                            displayScanResults(data);
                            // Initialize Plex, MusicBrainz, and Matcher integrations after deep scan
                            initPlexIntegration();
                            initMusicBrainzIntegration();
                            initMatcherIntegration();
                        }
                    }
                }
            }
        }
    } catch (error) {
        // Handle abort differently from other errors
        if (error.name === 'AbortError') {
            addScanLog('Scan cancelled by user', 'warning');
        } else {
            addScanLog(`Error: ${error.message}`, 'error');
        }
        organizerElements.scanBtn.disabled = false;
        organizerElements.scanBtn.textContent = 'Scan Library';
        organizerElements.cancelScanBtn.style.display = 'none';
        currentScanController = null;
    }
}

/**
 * ================================================================================
 * PLEX INTEGRATION (Phase 2.5)
 * ================================================================================
 */

/**
 * Initialize Plex integration after deep scan completes
 */
function initPlexIntegration() {
    console.log('[Plex] Initializing Plex integration...');
    console.log('[Plex] scanData:', scanData);

    // Get Plex DOM elements
    const plexSection = document.getElementById('plexSection');
    const plexConnectForm = document.getElementById('plexConnectForm');
    const connectionStatus = document.getElementById('connectionStatus');
    const plexLibraryPanel = document.getElementById('plexLibraryPanel');
    const fetchLibraryBtn = document.getElementById('fetchLibraryBtn');
    const newComparisonBtn = document.getElementById('newComparisonBtn');
    const exportReportBtn = document.getElementById('exportReportBtn');

    console.log('[Plex] plexSection element:', plexSection);
    console.log('[Plex] scanData exists:', !!scanData);

    // Show Plex section after successful deep scan
    if (plexSection && scanData) {
        console.log('[Plex] Showing Plex section');
        plexSection.style.display = 'block';
        addScanLog('Plex integration enabled - scroll down to connect', 'info');
    } else {
        console.warn('[Plex] Cannot show Plex section. plexSection:', !!plexSection, 'scanData:', !!scanData);
    }

    // Setup Plex event listeners
    if (plexConnectForm) {
        plexConnectForm.addEventListener('submit', handlePlexConnect);
    }

    if (fetchLibraryBtn) {
        fetchLibraryBtn.addEventListener('click', handleFetchLibrary);
    }

    if (newComparisonBtn) {
        newComparisonBtn.addEventListener('click', resetPlexComparison);
    }

    if (exportReportBtn) {
        exportReportBtn.addEventListener('click', exportComparisonReport);
    }

    // Setup filter buttons
    const filterButtons = document.querySelectorAll('.filter-btn');
    filterButtons.forEach(btn => {
        btn.addEventListener('click', (e) => {
            const filter = e.target.dataset.filter;
            setConflictFilter(filter);
        });
    });

    // Load saved Plex settings from localStorage
    loadPlexSettings();
}

/**
 * Load saved Plex settings from localStorage
 */
function loadPlexSettings() {
    const savedIp = localStorage.getItem('plexServerIp');
    const savedPort = localStorage.getItem('plexPort');
    const savedToken = localStorage.getItem('plexToken');

    if (savedIp) document.getElementById('plexServerIp').value = savedIp;
    if (savedPort) document.getElementById('plexPort').value = savedPort;
    if (savedToken) document.getElementById('plexToken').value = savedToken;
}

/**
 * Save Plex settings to localStorage
 */
function savePlexSettings(serverIp, port, token) {
    localStorage.setItem('plexServerIp', serverIp);
    localStorage.setItem('plexPort', port);
    localStorage.setItem('plexToken', token);
}

/**
 * Handle Plex connection test
 */
async function handlePlexConnect(e) {
    e.preventDefault();

    const serverIp = document.getElementById('plexServerIp').value.trim();
    const port = document.getElementById('plexPort').value.trim();
    const token = document.getElementById('plexToken').value.trim();

    const connectionStatus = document.getElementById('connectionStatus');
    const connectBtn = document.getElementById('plexConnectBtn');

    if (!serverIp || !port || !token) {
        showConnectionStatus('error', 'Please fill in all fields');
        return;
    }

    connectBtn.disabled = true;
    connectBtn.textContent = 'Testing...';
    connectionStatus.style.display = 'block';
    connectionStatus.className = 'connection-status info';
    connectionStatus.textContent = 'Testing connection to Plex server...';

    try {
        const response = await fetch('http://localhost:3000/api/plex/connect', {
            method: 'POST',
            headers: { 'Content-Type': 'application/json' },
            body: JSON.stringify({ serverIp, port, token })
        });

        const result = await response.json();

        if (result.success) {
            plexConnectionData = { serverIp, port, token };
            savePlexSettings(serverIp, port, token);
            showConnectionStatus('success', `Connected to ${result.server.name} (${result.server.version})`);

            // Fetch libraries
            await fetchLibraries();
        } else {
            showConnectionStatus('error', `Connection failed: ${result.error}`);
        }
    } catch (error) {
        showConnectionStatus('error', `Error: ${error.message}`);
    } finally {
        connectBtn.disabled = false;
        connectBtn.textContent = 'Test Connection';
    }
}

/**
 * Show connection status message
 */
function showConnectionStatus(type, message) {
    const connectionStatus = document.getElementById('connectionStatus');
    connectionStatus.style.display = 'block';
    connectionStatus.className = `connection-status ${type}`;
    connectionStatus.textContent = message;
}

/**
 * Fetch Plex libraries
 */
async function fetchLibraries() {
    if (!plexConnectionData) return;

    const { serverIp, port, token } = plexConnectionData;

    try {
        const response = await fetch('http://localhost:3000/api/plex/libraries', {
            method: 'POST',
            headers: { 'Content-Type': 'application/json' },
            body: JSON.stringify({ serverIp, port, token })
        });

        const result = await response.json();

        if (result.success && result.libraries.length > 0) {
            plexLibraries = result.libraries;
            displayLibraries(result.libraries);
        } else {
            showConnectionStatus('warning', 'No music libraries found on this Plex server');
        }
    } catch (error) {
        showConnectionStatus('error', `Failed to fetch libraries: ${error.message}`);
    }
}

/**
 * Display Plex music libraries
 */
function displayLibraries(libraries) {
    const libraryList = document.getElementById('libraryList');
    const plexLibraryPanel = document.getElementById('plexLibraryPanel');

    libraryList.innerHTML = '';

    libraries.forEach(library => {
        const card = document.createElement('div');
        card.className = 'library-card';
        card.innerHTML = `
            <input type="radio" name="library" value="${library.id}" id="library-${library.id}">
            <label for="library-${library.id}">
                <strong>${library.name}</strong>
                <span class="library-count">${library.trackCount} tracks</span>
            </label>
        `;

        card.querySelector('input').addEventListener('change', (e) => {
            selectedLibraryId = e.target.value;
            document.getElementById('fetchLibraryBtn').style.display = 'inline-block';
        });

        libraryList.appendChild(card);
    });

    plexLibraryPanel.style.display = 'block';
}

/**
 * Handle fetch library tracks
 */
async function handleFetchLibrary() {
    if (!selectedLibraryId || !plexConnectionData) return;

    const { serverIp, port, token } = plexConnectionData;
    const fetchBtn = document.getElementById('fetchLibraryBtn');
    const progressContainer = document.getElementById('plexProgressContainer');
    const progressBar = document.getElementById('plexProgressBar');
    const progressText = document.getElementById('plexProgressText');

    fetchBtn.disabled = true;
    fetchBtn.textContent = 'Fetching...';
    progressContainer.style.display = 'block';

    try {
        const response = await fetch('http://localhost:3000/api/plex/fetch', {
            method: 'POST',
            headers: { 'Content-Type': 'application/json' },
            body: JSON.stringify({ serverIp, port, token, libraryId: selectedLibraryId })
        });

        const reader = response.body.getReader();
        const decoder = new TextDecoder();
        let buffer = '';

        while (true) {
            const { done, value } = await reader.read();
            if (done) break;

            buffer += decoder.decode(value, { stream: true });
            const lines = buffer.split('\n');

            // Keep the last incomplete line in the buffer
            buffer = lines.pop() || '';

            for (const line of lines) {
                if (line.startsWith('data: ')) {
                    try {
                        const data = JSON.parse(line.slice(6));

                        if (data.progress !== undefined) {
                            progressBar.style.width = data.progress + '%';
                        }

                        if (data.status) {
                            progressText.textContent = data.status;
                        }

                        if (data.completed && data.tracks) {
                            plexTracks = data.tracks;
                            addScanLog(`Fetched ${data.tracks.length} tracks from Plex library`, 'success');

                            // Now compare with offline library
                            await compareLibraries();
                        }

                        if (data.error) {
                            addScanLog(`Plex fetch error: ${data.error}`, 'error');
                        }
                    } catch (parseError) {
                        console.error('[Plex Fetch] JSON parse error:', parseError);
                        console.error('[Plex Fetch] Failed to parse line:', line.substring(0, 200));
                    }
                }
            }
        }
    } catch (error) {
        addScanLog(`Error fetching Plex library: ${error.message}`, 'error');
    } finally {
        fetchBtn.disabled = false;
        fetchBtn.textContent = 'Fetch Library Tracks';
        progressContainer.style.display = 'none';
    }
}

/**
 * Compare offline library with Plex library
 */
async function compareLibraries() {
    if (!scanData || !plexTracks) {
        addScanLog('Missing scan data or Plex tracks', 'error');
        return;
    }

    // Convert scanData to format expected by backend
    const offlineTracks = [];
    for (const letter in scanData.groupedByArtist) {
        const group = scanData.groupedByArtist[letter];
        for (const file of group.files) {
            offlineTracks.push({
                artist: file.metadata?.artist || file.folderArtist || 'Unknown',
                album: file.metadata?.album || 'Unknown',
                title: file.metadata?.title || file.fileName,
                format: file.metadata?.format || 'unknown',
                bitrate: file.metadata?.bitrate || null
            });
        }
    }

    addScanLog(`Comparing ${offlineTracks.length} offline tracks with ${plexTracks.length} Plex tracks...`, 'info');

    const progressContainer = document.getElementById('plexProgressContainer');
    const progressBar = document.getElementById('plexProgressBar');
    const progressText = document.getElementById('plexProgressText');

    progressContainer.style.display = 'block';
    progressText.textContent = 'Comparing libraries...';

    try {
        const response = await fetch('http://localhost:3000/api/plex/compare', {
            method: 'POST',
            headers: { 'Content-Type': 'application/json' },
            body: JSON.stringify({ offlineTracks, plexTracks })
        });

        const reader = response.body.getReader();
        const decoder = new TextDecoder();

        while (true) {
            const { done, value } = await reader.read();
            if (done) break;

            const chunk = decoder.decode(value);
            const lines = chunk.split('\n');

            for (const line of lines) {
                if (line.startsWith('data: ')) {
                    const data = JSON.parse(line.slice(6));

                    if (data.progress !== undefined) {
                        progressBar.style.width = data.progress + '%';
                    }

                    if (data.status) {
                        progressText.textContent = data.status;
                    }

                    if (data.completed && data.results) {
                        comparisonResults = data.results;
                        displayComparisonResults(data.results);
                        addScanLog('Comparison complete!', 'success');
                    }

                    if (data.error) {
                        addScanLog(`Comparison error: ${data.error}`, 'error');
                    }
                }
            }
        }
    } catch (error) {
        addScanLog(`Error comparing libraries: ${error.message}`, 'error');
    } finally {
        progressContainer.style.display = 'none';
    }
}

/**
 * Display comparison results
 */
function displayComparisonResults(results) {
    // Update summary statistics
    document.getElementById('statSafeToAdd').textContent = results.safeToAdd;
    document.getElementById('statUpgrades').textContent = results.qualityUpgrades;
    document.getElementById('statDowngrades').textContent = results.qualityDowngrades;
    document.getElementById('statDuplicates').textContent = results.sameQualityDupes;

    // Display conflicts table
    displayConflictsTable(results.conflicts);

    // Show results panel
    document.getElementById('comparisonResults').style.display = 'block';
}

/**
 * Display conflicts table
 */
function displayConflictsTable(conflicts) {
    const tbody = document.getElementById('conflictsTableBody');
    tbody.innerHTML = '';

    const filteredConflicts = currentFilterCategory === 'all'
        ? conflicts
        : conflicts.filter(c => c.category === currentFilterCategory);

    filteredConflicts.forEach(conflict => {
        const row = document.createElement('tr');
        row.className = `conflict-row ${conflict.category.toLowerCase().replace(/_/g, '-')}`;
        row.dataset.category = conflict.category;

        const offlineQuality = conflict.offlineTrack.format
            ? `${conflict.offlineTrack.format}${conflict.offlineTrack.bitrate ? ` (${conflict.offlineTrack.bitrate}kbps)` : ''}`
            : 'Unknown';

        const plexQuality = conflict.plexTrack
            ? `${conflict.plexTrack.codec || 'Unknown'}${conflict.plexTrack.bitrate ? ` (${conflict.plexTrack.bitrate}kbps)` : ''}`
            : '--';

        const statusBadge = getStatusBadge(conflict.category);
        const recommendationBadge = getRecommendationBadge(conflict.recommendation);

        row.innerHTML = `
            <td>${conflict.offlineTrack.artist}</td>
            <td>${conflict.offlineTrack.album}</td>
            <td>${conflict.offlineTrack.title}</td>
            <td>${offlineQuality}</td>
            <td>${plexQuality}</td>
            <td>${statusBadge}</td>
            <td>${recommendationBadge}</td>
        `;

        tbody.appendChild(row);
    });
}

/**
 * Get status badge HTML
 */
function getStatusBadge(category) {
    const badges = {
        'SAFE_TO_ADD': '<span class="badge badge-safe">Safe to Add</span>',
        'QUALITY_UPGRADE': '<span class="badge badge-upgrade">Quality Upgrade</span>',
        'QUALITY_DOWNGRADE': '<span class="badge badge-downgrade">Quality Downgrade</span>',
        'SAME_QUALITY_DUPLICATE': '<span class="badge badge-duplicate">Duplicate</span>'
    };
    return badges[category] || '<span class="badge">Unknown</span>';
}

/**
 * Get recommendation badge HTML
 */
function getRecommendationBadge(recommendation) {
    const badges = {
        'ADD': '<span class="badge-rec badge-rec-add">Add</span>',
        'REPLACE': '<span class="badge-rec badge-rec-replace">Replace</span>',
        'SKIP': '<span class="badge-rec badge-rec-skip">Skip</span>'
    };
    return badges[recommendation] || '<span class="badge-rec">--</span>';
}

/**
 * Set conflict filter
 */
function setConflictFilter(filter) {
    currentFilterCategory = filter;

    // Update active button
    document.querySelectorAll('.filter-btn').forEach(btn => {
        btn.classList.toggle('active', btn.dataset.filter === filter);
    });

    // Re-render table
    if (comparisonResults) {
        displayConflictsTable(comparisonResults.conflicts);
    }
}

/**
 * Export comparison report as CSV
 */
function exportComparisonReport() {
    if (!comparisonResults) return;

    const headers = ['Artist', 'Album', 'Title', 'Offline Format', 'Offline Bitrate', 'Plex Format', 'Plex Bitrate', 'Status', 'Recommendation'];
    const rows = [headers];

    comparisonResults.conflicts.forEach(conflict => {
        rows.push([
            conflict.offlineTrack.artist,
            conflict.offlineTrack.album,
            conflict.offlineTrack.title,
            conflict.offlineTrack.format || 'Unknown',
            conflict.offlineTrack.bitrate || '',
            conflict.plexTrack ? (conflict.plexTrack.codec || 'Unknown') : '',
            conflict.plexTrack ? (conflict.plexTrack.bitrate || '') : '',
            conflict.category,
            conflict.recommendation
        ]);
    });

    const csv = rows.map(row => row.map(cell => `"${cell}"`).join(',')).join('\n');
    const blob = new Blob([csv], { type: 'text/csv' });
    const url = URL.createObjectURL(blob);
    const a = document.createElement('a');
    a.href = url;
    a.download = `plex-comparison-${new Date().toISOString().split('T')[0]}.csv`;
    a.click();
    URL.revokeObjectURL(url);

    addScanLog('Comparison report exported to CSV', 'success');
}

/**
 * Reset Plex comparison
 */
function resetPlexComparison() {
    plexConnectionData = null;
    plexLibraries = null;
    selectedLibraryId = null;
    plexTracks = null;
    comparisonResults = null;
    currentFilterCategory = 'all';

    document.getElementById('plexSection').style.display = 'none';
    document.getElementById('plexLibraryPanel').style.display = 'none';
    document.getElementById('comparisonResults').style.display = 'none';
    document.getElementById('connectionStatus').style.display = 'none';

    addScanLog('Plex comparison reset', 'info');
}

/**
 * ================================================================================
 * MUSICBRAINZ INTEGRATION (Phase 3)
 * ================================================================================
 */

/**
 * Initialize MusicBrainz integration after deep scan completes
 */
function initMusicBrainzIntegration() {
    console.log('[MusicBrainz] Initializing MusicBrainz integration...');

    const mbSection = document.getElementById('musicbrainzSection');
    const mbArtistForm = document.getElementById('mbArtistSearchForm');
    const mbReleaseForm = document.getElementById('mbReleaseSearchForm');
    const mbRecordingForm = document.getElementById('mbRecordingSearchForm');

    // Show MusicBrainz section
    if (mbSection && scanData) {
        console.log('[MusicBrainz] Showing MusicBrainz section');
        mbSection.style.display = 'block';
        addScanLog('MusicBrainz metadata search enabled - scroll down to search', 'info');
    }

    // Setup event listeners
    if (mbArtistForm) {
        mbArtistForm.addEventListener('submit', handleMbArtistSearch);
    }

    if (mbReleaseForm) {
        mbReleaseForm.addEventListener('submit', handleMbReleaseSearch);
    }

    if (mbRecordingForm) {
        mbRecordingForm.addEventListener('submit', handleMbRecordingSearch);
    }
}

/**
 * Handle MusicBrainz artist search
 */
async function handleMbArtistSearch(e) {
    e.preventDefault();

    const artist = document.getElementById('mbArtistInput').value.trim();
    const resultsEl = document.getElementById('mbArtistResults');

    if (!artist) return;

    resultsEl.innerHTML = '<div class="loading">Searching MusicBrainz for artist...</div>';

    try {
        const response = await fetch('http://localhost:3000/api/musicbrainz/search-artist', {
            method: 'POST',
            headers: { 'Content-Type': 'application/json' },
            body: JSON.stringify({ artist })
        });

        const result = await response.json();

        if (result.success && result.results.length > 0) {
            displayMbArtistResults(result.results);
        } else {
            resultsEl.innerHTML = '<div class="no-results">No artists found</div>';
        }
    } catch (error) {
        resultsEl.innerHTML = `<div class="error">Error: ${error.message}</div>`;
    }
}

/**
 * Display MusicBrainz artist results
 */
function displayMbArtistResults(results) {
    const resultsEl = document.getElementById('mbArtistResults');

    let html = '<div class="mb-result-list">';

    results.forEach((artist, index) => {
        html += `
            <div class="mb-result-item" style="margin-bottom: 15px; padding: 15px; border: 1px solid #e1e8ed; border-radius: 4px;">
                <div style="display: flex; justify-content: space-between; align-items: start;">
                    <div style="flex: 1;">
                        <h4 style="margin: 0 0 8px 0; color: #2c3e50;">${artist.name}</h4>
                        <div style="font-size: 13px; color: #64748b; margin-bottom: 5px;">
                            <span class="format-badge" style="background-color: ${getConfidenceBadgeColor(artist.confidence)};">
                                ${artist.confidence}% match
                            </span>
                            ${artist.type ? `<span class="format-badge">${artist.type}</span>` : ''}
                            ${artist.country ? `<span class="format-badge">${artist.country}</span>` : ''}
                        </div>
                        ${artist.disambiguation ? `<div style="font-size: 13px; color: #94a3b8; margin-top: 5px;">${artist.disambiguation}</div>` : ''}
                        ${artist.aliases.length > 0 ? `
                            <div style="font-size: 12px; color: #94a3b8; margin-top: 8px;">
                                <strong>Aliases:</strong> ${artist.aliases.slice(0, 3).map(a => a.name).join(', ')}
                                ${artist.aliases.length > 3 ? ` (+${artist.aliases.length - 3} more)` : ''}
                            </div>
                        ` : ''}
                    </div>
                    <div style="font-size: 11px; color: #94a3b8; margin-left: 15px;">
                        ID: ${artist.id}
                    </div>
                </div>
            </div>
        `;
    });

    html += '</div>';
    resultsEl.innerHTML = html;
}

/**
 * Handle MusicBrainz release search
 */
async function handleMbReleaseSearch(e) {
    e.preventDefault();

    const artist = document.getElementById('mbReleaseArtistInput').value.trim();
    const album = document.getElementById('mbReleaseAlbumInput').value.trim();
    const resultsEl = document.getElementById('mbReleaseResults');

    if (!artist || !album) return;

    resultsEl.innerHTML = '<div class="loading">Searching MusicBrainz for release...</div>';

    try {
        const response = await fetch('http://localhost:3000/api/musicbrainz/search-release', {
            method: 'POST',
            headers: { 'Content-Type': 'application/json' },
            body: JSON.stringify({ artist, album })
        });

        const result = await response.json();

        if (result.success && result.results.length > 0) {
            displayMbReleaseResults(result.results);
        } else {
            resultsEl.innerHTML = '<div class="no-results">No releases found</div>';
        }
    } catch (error) {
        resultsEl.innerHTML = `<div class="error">Error: ${error.message}</div>`;
    }
}

/**
 * Display MusicBrainz release results
 */
function displayMbReleaseResults(results) {
    const resultsEl = document.getElementById('mbReleaseResults');

    let html = '<div class="mb-result-list">';

    results.forEach((release, index) => {
        html += `
            <div class="mb-result-item" style="margin-bottom: 15px; padding: 15px; border: 1px solid #e1e8ed; border-radius: 4px;">
                <div style="display: flex; justify-content: space-between; align-items: start;">
                    <div style="flex: 1;">
                        <h4 style="margin: 0 0 8px 0; color: #2c3e50;">${release.title}</h4>
                        <div style="font-size: 14px; color: #64748b; margin-bottom: 8px;">by ${release.artist}</div>
                        <div style="font-size: 13px; color: #64748b; margin-bottom: 5px;">
                            <span class="format-badge" style="background-color: ${getConfidenceBadgeColor(release.confidence)};">
                                ${release.confidence}% match
                            </span>
                            ${release.date ? `<span class="format-badge">${release.date}</span>` : ''}
                            ${release.country ? `<span class="format-badge">${release.country}</span>` : ''}
                            ${release.trackCount ? `<span class="format-badge">${release.trackCount} tracks</span>` : ''}
                        </div>
                        ${release.status ? `<div style="font-size: 13px; color: #94a3b8;">Status: ${release.status}</div>` : ''}
                    </div>
                    <div style="font-size: 11px; color: #94a3b8; margin-left: 15px;">
                        ID: ${release.id}
                    </div>
                </div>
            </div>
        `;
    });

    html += '</div>';
    resultsEl.innerHTML = html;
}

/**
 * Handle MusicBrainz recording search
 */
async function handleMbRecordingSearch(e) {
    e.preventDefault();

    const artist = document.getElementById('mbRecordingArtistInput').value.trim();
    const album = document.getElementById('mbRecordingAlbumInput').value.trim();
    const title = document.getElementById('mbRecordingTitleInput').value.trim();
    const resultsEl = document.getElementById('mbRecordingResults');

    if (!artist || !album || !title) return;

    resultsEl.innerHTML = '<div class="loading">Searching MusicBrainz for recording...</div>';

    try {
        const response = await fetch('http://localhost:3000/api/musicbrainz/search-recording', {
            method: 'POST',
            headers: { 'Content-Type': 'application/json' },
            body: JSON.stringify({ artist, album, title })
        });

        const result = await response.json();

        if (result.success && result.results.length > 0) {
            displayMbRecordingResults(result.results);
        } else {
            resultsEl.innerHTML = '<div class="no-results">No recordings found</div>';
        }
    } catch (error) {
        resultsEl.innerHTML = `<div class="error">Error: ${error.message}</div>`;
    }
}

/**
 * Display MusicBrainz recording results
 */
function displayMbRecordingResults(results) {
    const resultsEl = document.getElementById('mbRecordingResults');

    let html = '<div class="mb-result-list">';

    results.forEach((recording, index) => {
        const duration = recording.length ? Math.floor(recording.length / 1000 / 60) + ':' + String(Math.floor((recording.length / 1000) % 60)).padStart(2, '0') : 'Unknown';

        html += `
            <div class="mb-result-item" style="margin-bottom: 15px; padding: 15px; border: 1px solid #e1e8ed; border-radius: 4px;">
                <div style="display: flex; justify-content: space-between; align-items: start;">
                    <div style="flex: 1;">
                        <h4 style="margin: 0 0 8px 0; color: #2c3e50;">${recording.title}</h4>
                        <div style="font-size: 14px; color: #64748b; margin-bottom: 8px;">by ${recording.artist}</div>
                        <div style="font-size: 13px; color: #64748b; margin-bottom: 5px;">
                            <span class="format-badge" style="background-color: ${getConfidenceBadgeColor(recording.confidence)};">
                                ${recording.confidence}% match
                            </span>
                            ${recording.length ? `<span class="format-badge">${duration}</span>` : ''}
                        </div>
                        ${recording.releases && recording.releases.length > 0 ? `
                            <div style="font-size: 12px; color: #94a3b8; margin-top: 8px;">
                                <strong>Found on:</strong> ${recording.releases.slice(0, 2).map(r => `${r.title}${r.date ? ` (${r.date})` : ''}`).join(', ')}
                                ${recording.releases.length > 2 ? ` (+${recording.releases.length - 2} more)` : ''}
                            </div>
                        ` : ''}
                    </div>
                    <div style="font-size: 11px; color: #94a3b8; margin-left: 15px;">
                        ID: ${recording.id}
                    </div>
                </div>
            </div>
        `;
    });

    html += '</div>';
    resultsEl.innerHTML = html;
}

/**
 * Get confidence badge color based on percentage
 */
function getConfidenceBadgeColor(confidence) {
    if (confidence >= 90) return '#10b981'; // green
    if (confidence >= 70) return '#f59e0b'; // amber
    return '#ef4444'; // red
}

/**
 * ================================================================================
 * AUTO-MATCH & RENAME ENGINE (Phase 3.5)
 * ================================================================================
 */

// Global state for matcher
let matchResults = [];
let renamePreviews = null;
let currentMatchFilter = 'all';

/**
 * Initialize Auto-Match & Rename integration after deep scan completes
 */
function initMatcherIntegration() {
    console.log('[Matcher] Initializing Auto-Match & Rename integration...');

    const matcherSection = document.getElementById('matcherSection');
    const startBatchMatchBtn = document.getElementById('startBatchMatchBtn');
    const previewRenamesBtn = document.getElementById('previewRenamesBtn');
    const executeDryRunBtn = document.getElementById('executeDryRunBtn');
    const executeRenameBtn = document.getElementById('executeRenameBtn');

    // Show matcher section
    if (matcherSection && scanData) {
        matcherSection.style.display = 'block';
        addScanLog('Auto-Match & Rename engine ready - scroll down to start', 'info');
    }

    // Setup event listeners
    if (startBatchMatchBtn) {
        startBatchMatchBtn.addEventListener('click', handleStartBatchMatch);
    }

    // Three-phase matching buttons
    const matchArtistsBtn = document.getElementById('matchArtistsBtn');
    const matchAlbumsBtn = document.getElementById('matchAlbumsBtn');
    const matchTracksBtn = document.getElementById('matchTracksBtn');

    if (matchArtistsBtn) {
        matchArtistsBtn.addEventListener('click', handleMatchArtists);
    }
    if (matchAlbumsBtn) {
        matchAlbumsBtn.addEventListener('click', handleMatchAlbums);
    }
    if (matchTracksBtn) {
        matchTracksBtn.addEventListener('click', handleMatchTracks);
    }

    if (previewRenamesBtn) {
        previewRenamesBtn.addEventListener('click', handlePreviewRenames);
    }

    if (executeDryRunBtn) {
        executeDryRunBtn.addEventListener('click', () => handleExecuteRename(true));
    }

    if (executeRenameBtn) {
        executeRenameBtn.addEventListener('click', () => handleExecuteRename(false));
    }

    // Setup filter buttons
    const filterButtons = document.querySelectorAll('#matchResultsContainer .filter-btn');
    filterButtons.forEach(btn => {
        btn.addEventListener('click', (e) => {
            filterButtons.forEach(b => b.classList.remove('active'));
            e.target.classList.add('active');
            currentMatchFilter = e.target.dataset.filter;
            displayMatchResults(matchResults, currentMatchFilter);
        });
    });
}

/**
 * Handle Start Batch Match button click
 */
async function handleStartBatchMatch() {
    console.log('[Matcher] Starting batch match...');

    if (!scanData || !scanData.files || scanData.files.length === 0) {
        addScanLog('No scanned files to match. Please run a deep scan first.', 'error');
        return;
    }

    const startBtn = document.getElementById('startBatchMatchBtn');
    const progressContainer = document.getElementById('matchProgressContainer');
    const progressText = document.getElementById('matchProgressText');
    const progressBar = document.getElementById('matchProgressBar');
    const statsContainer = document.getElementById('matchStatsContainer');

    // Show progress UI
    startBtn.disabled = true;
    progressContainer.style.display = 'block';
    statsContainer.style.display = 'none';

    try {
        const eventSource = await fetch('http://localhost:3000/api/matcher/batch-match', {
            method: 'POST',
            headers: { 'Content-Type': 'application/json' },
            body: JSON.stringify({ files: scanData.files })
        });

        const reader = eventSource.body.getReader();
        const decoder = new TextDecoder();

        while (true) {
            const { done, value } = await reader.read();
            if (done) break;

            const chunk = decoder.decode(value);
            const lines = chunk.split('\n');

            for (const line of lines) {
                if (line.startsWith('data: ')) {
                    try {
                        const data = JSON.parse(line.slice(6));

                        if (data.type === 'progress') {
                            progressText.textContent = `Matching ${data.currentFile || ''}... (${data.processed}/${data.total})`;
                            progressBar.style.width = `${data.progress}%`;
                        } else if (data.type === 'complete') {
                            console.log('[Matcher] Batch match complete:', data);
                            matchResults = data.results;

                            progressText.textContent = data.message;
                            progressBar.style.width = '100%';

                            // Show statistics
                            displayMatchStatistics(data.stats);
                            statsContainer.style.display = 'block';

                            // Show match results
                            displayMatchResults(matchResults, 'all');
                            document.getElementById('matchResultsContainer').style.display = 'block';

                            // Show Step 2: Output Directory configuration
                            document.getElementById('outputDirectoryContainer').style.display = 'block';

                            addScanLog(`Batch matching complete! ${data.stats.matched}/${data.stats.total} files matched`, 'success');

                            // Scroll to match results (increased delay for DOM to update)
                            setTimeout(() => scrollToElement('#matchStatsContainer'), 400);
                        } else if (data.type === 'error') {
                            progressText.textContent = `Error: ${data.error}`;
                            addScanLog(`Batch match error: ${data.error}`, 'error');
                        }
                    } catch (parseError) {
                        console.error('[Matcher] Parse error:', parseError);
                    }
                }
            }
        }
    } catch (error) {
        console.error('[Matcher] Batch match error:', error);
        progressText.textContent = `Error: ${error.message}`;
        addScanLog(`Batch match error: ${error.message}`, 'error');
    } finally {
        startBtn.disabled = false;
    }
}

/**
 * Handle Phase 1: Match Artists
 */
async function handleMatchArtists() {
    console.log('[Matcher] Phase 1: Starting artist matching...');
    console.log('[Matcher] scanData:', scanData);
    console.log('[Matcher] scanData.files:', scanData?.files);
    console.log('[Matcher] scanData.files.length:', scanData?.files?.length);

    if (!scanData || !scanData.files || scanData.files.length === 0) {
        console.error('[Matcher] scanData validation failed!', {
            hasScanData: !!scanData,
            hasFiles: !!scanData?.files,
            filesLength: scanData?.files?.length
        });
        addScanLog('No scanned files to match. Please run a deep scan first.', 'error');
        alert('No scanned files found! Please run a Deep Scan first, then try Phase 1 again.');
        return;
    }

    const matchArtistsBtn = document.getElementById('matchArtistsBtn');
    const matchAlbumsBtn = document.getElementById('matchAlbumsBtn');
    const matchTracksBtn = document.getElementById('matchTracksBtn');
    const progressContainer = document.getElementById('matchProgressContainer');
    const progressText = document.getElementById('matchProgressText');
    const progressBar = document.getElementById('matchProgressBar');
    const statsContainer = document.getElementById('matchStatsContainer');

    // Show progress UI
    matchArtistsBtn.disabled = true;
    matchAlbumsBtn.disabled = true;
    matchTracksBtn.disabled = true;
    progressContainer.style.display = 'block';
    statsContainer.style.display = 'none';

    try {
        const eventSource = await fetch('http://localhost:3000/api/matcher/match-artists', {
            method: 'POST',
            headers: { 'Content-Type': 'application/json' },
            body: JSON.stringify({ files: scanData.files })
        });

        const reader = eventSource.body.getReader();
        const decoder = new TextDecoder();

        while (true) {
            const { done, value } = await reader.read();
            console.log('[Matcher] SSE read:', { done, valueLength: value?.length });
            if (done) {
                console.log('[Matcher] SSE stream ended');
                break;
            }

            const chunk = decoder.decode(value);
            console.log('[Matcher] SSE chunk received:', chunk.substring(0, 200));
            const lines = chunk.split('\n');

            for (const line of lines) {
                if (line.startsWith('data: ')) {
                    try {
                        const data = JSON.parse(line.slice(6));
                        console.log('[Matcher] SSE message type:', data.type);

                        if (data.type === 'progress') {
                            progressText.textContent = `Phase 1: Matching artist "${data.currentArtist || ''}"... (${data.processed}/${data.total})`;
                            progressBar.style.width = `${data.progress}%`;
                        } else if (data.type === 'complete') {
                            console.log('[Matcher] Phase 1 complete:', data);
                            console.log('[Matcher] Artist results:', data.results);
                            artistMatchResults = data.results;

                            progressText.textContent = data.message;
                            progressBar.style.width = '100%';

                            // Show statistics
                            displayMatchStatistics(data.stats);
                            statsContainer.style.display = 'block';

                            // Show artist match results
                            displayArtistMatchResults(artistMatchResults, 'all');
                            document.getElementById('matchResultsContainer').style.display = 'block';

                            // Attach event listeners to action buttons using event delegation
                            attachArtistMatchActionListeners();

                            addScanLog(`Phase 1 complete! Matched ${data.stats.autoApprove + data.stats.review}/${data.stats.total} artists`, 'success');

                            // Enable Phase 2 button
                            matchAlbumsBtn.disabled = false;
                            matchAlbumsBtn.classList.remove('button-secondary');
                            matchAlbumsBtn.classList.add('button-primary');

                            // Scroll to results
                            setTimeout(() => scrollToElement('#matchStatsContainer'), 400);
                        } else if (data.type === 'error') {
                            progressText.textContent = `Error: ${data.error}`;
                            addScanLog(`Phase 1 error: ${data.error}`, 'error');
                        }
                    } catch (parseError) {
                        console.error('[Matcher] Parse error:', parseError);
                    }
                }
            }
        }
    } catch (error) {
        console.error('[Matcher] Phase 1 error:', error);
        progressText.textContent = `Error: ${error.message}`;
        addScanLog(`Phase 1 error: ${error.message}`, 'error');
    } finally {
        matchArtistsBtn.disabled = false;
    }
}

/**
 * Handle Phase 2: Match Albums
 */
async function handleMatchAlbums() {
    console.log('[Matcher] Phase 2: Starting album matching...');

    if (!artistMatchResults || artistMatchResults.length === 0) {
        addScanLog('Please complete Phase 1 (Match Artists) first.', 'error');
        return;
    }

    const matchArtistsBtn = document.getElementById('matchArtistsBtn');
    const matchAlbumsBtn = document.getElementById('matchAlbumsBtn');
    const matchTracksBtn = document.getElementById('matchTracksBtn');
    const progressContainer = document.getElementById('matchProgressContainer');
    const progressText = document.getElementById('matchProgressText');
    const progressBar = document.getElementById('matchProgressBar');
    const statsContainer = document.getElementById('matchStatsContainer');

    // Show progress UI
    matchArtistsBtn.disabled = true;
    matchAlbumsBtn.disabled = true;
    matchTracksBtn.disabled = true;
    progressContainer.style.display = 'block';
    statsContainer.style.display = 'none';

    try {
        const eventSource = await fetch('http://localhost:3000/api/matcher/match-albums', {
            method: 'POST',
            headers: { 'Content-Type': 'application/json' },
            body: JSON.stringify({
                files: scanData.files,
                artistMatches: artistMatchResults
            })
        });

        const reader = eventSource.body.getReader();
        const decoder = new TextDecoder();

        while (true) {
            const { done, value } = await reader.read();
            if (done) break;

            const chunk = decoder.decode(value);
            const lines = chunk.split('\n');

            for (const line of lines) {
                if (line.startsWith('data: ')) {
                    try {
                        const data = JSON.parse(line.slice(6));

                        if (data.type === 'progress') {
                            progressText.textContent = `Phase 2: Matching album "${data.currentAlbum || ''}"... (${data.processed}/${data.total})`;
                            progressBar.style.width = `${data.progress}%`;
                        } else if (data.type === 'complete') {
                            console.log('[Matcher] Phase 2 complete:', data);
                            albumMatchResults = data.results;

                            progressText.textContent = data.message;
                            progressBar.style.width = '100%';

                            // Show statistics
                            displayMatchStatistics(data.stats);
                            statsContainer.style.display = 'block';

                            // Show album match results
                            displayAlbumMatchResults(albumMatchResults, 'all');
                            document.getElementById('matchResultsContainer').style.display = 'block';

                            // Attach event listeners to action buttons using event delegation
                            attachAlbumMatchActionListeners();

                            addScanLog(`Phase 2 complete! Matched ${data.stats.autoApprove + data.stats.review}/${data.stats.total} albums`, 'success');

                            // Enable Phase 3 button
                            matchTracksBtn.disabled = false;
                            matchTracksBtn.classList.remove('button-secondary');
                            matchTracksBtn.classList.add('button-primary');

                            // Scroll to results
                            setTimeout(() => scrollToElement('#matchStatsContainer'), 400);
                        } else if (data.type === 'error') {
                            progressText.textContent = `Error: ${data.error}`;
                            addScanLog(`Phase 2 error: ${data.error}`, 'error');
                        }
                    } catch (parseError) {
                        console.error('[Matcher] Parse error:', parseError);
                    }
                }
            }
        }
    } catch (error) {
        console.error('[Matcher] Phase 2 error:', error);
        progressText.textContent = `Error: ${error.message}`;
        addScanLog(`Phase 2 error: ${error.message}`, 'error');
    } finally {
        matchArtistsBtn.disabled = false;
        matchAlbumsBtn.disabled = false;
    }
}

/**
 * Handle Phase 3: Match Tracks
 */
async function handleMatchTracks() {
    console.log('[Matcher] Phase 3: Starting track matching...');

    if (!artistMatchResults || artistMatchResults.length === 0) {
        addScanLog('Please complete Phase 1 (Match Artists) first.', 'error');
        return;
    }

    if (!albumMatchResults || albumMatchResults.length === 0) {
        addScanLog('Please complete Phase 2 (Match Albums) first.', 'error');
        return;
    }

    const matchArtistsBtn = document.getElementById('matchArtistsBtn');
    const matchAlbumsBtn = document.getElementById('matchAlbumsBtn');
    const matchTracksBtn = document.getElementById('matchTracksBtn');
    const progressContainer = document.getElementById('matchProgressContainer');
    const progressText = document.getElementById('matchProgressText');
    const progressBar = document.getElementById('matchProgressBar');
    const statsContainer = document.getElementById('matchStatsContainer');

    // Show progress UI
    matchArtistsBtn.disabled = true;
    matchAlbumsBtn.disabled = true;
    matchTracksBtn.disabled = true;
    progressContainer.style.display = 'block';
    statsContainer.style.display = 'none';

    try {
        const eventSource = await fetch('http://localhost:3000/api/matcher/match-tracks', {
            method: 'POST',
            headers: { 'Content-Type': 'application/json' },
            body: JSON.stringify({
                files: scanData.files,
                artistMatches: artistMatchResults,
                albumMatches: albumMatchResults
            })
        });

        const reader = eventSource.body.getReader();
        const decoder = new TextDecoder();

        while (true) {
            const { done, value } = await reader.read();
            if (done) break;

            const chunk = decoder.decode(value);
            const lines = chunk.split('\n');

            for (const line of lines) {
                if (line.startsWith('data: ')) {
                    try {
                        const data = JSON.parse(line.slice(6));

                        if (data.type === 'progress') {
                            progressText.textContent = `Phase 3: Matching track "${data.currentFile || ''}"... (${data.processed}/${data.total})`;
                            progressBar.style.width = `${data.progress}%`;
                        } else if (data.type === 'complete') {
                            console.log('[Matcher] Phase 3 complete:', data);
                            matchResults = data.results;

                            progressText.textContent = data.message;
                            progressBar.style.width = '100%';

                            // Show statistics
                            displayMatchStatistics(data.stats);
                            statsContainer.style.display = 'block';

                            // Show track match results (use existing displayMatchResults)
                            displayMatchResults(matchResults, 'all');
                            document.getElementById('matchResultsContainer').style.display = 'block';

                            // Show Step 2: Output Directory configuration
                            document.getElementById('outputDirectoryContainer').style.display = 'block';

                            addScanLog(`Phase 3 complete! Matched ${data.stats.matched}/${data.stats.total} tracks`, 'success');

                            // Scroll to results
                            setTimeout(() => scrollToElement('#matchStatsContainer'), 400);
                        } else if (data.type === 'error') {
                            progressText.textContent = `Error: ${data.error}`;
                            addScanLog(`Phase 3 error: ${data.error}`, 'error');
                        }
                    } catch (parseError) {
                        console.error('[Matcher] Parse error:', parseError);
                    }
                }
            }
        }
    } catch (error) {
        console.error('[Matcher] Phase 3 error:', error);
        progressText.textContent = `Error: ${error.message}`;
        addScanLog(`Phase 3 error: ${error.message}`, 'error');
    } finally {
        matchArtistsBtn.disabled = false;
        matchAlbumsBtn.disabled = false;
        matchTracksBtn.disabled = false;
    }
}

/**
 * Display match statistics
 */
function displayMatchStatistics(stats) {
    // Handle both old format (stats.byCategory) and new format (stats.autoApprove)
    const autoApprove = stats.autoApprove ?? stats.byCategory?.auto_approve ?? 0;
    const review = stats.review ?? stats.byCategory?.review ?? 0;
    const manual = stats.manual ?? stats.byCategory?.manual ?? 0;
    const skipped = (stats.skipped ?? 0) + (stats.errors ?? 0);

    document.getElementById('statAutoApprove').textContent = autoApprove;
    document.getElementById('statReview').textContent = review;
    document.getElementById('statManual').textContent = manual;
    document.getElementById('statSkipped').textContent = skipped;
}

/**
 * Display Phase 1 artist match results
 */
function displayArtistMatchResults(results, filter = 'all') {
    const resultsList = document.getElementById('matchResultsList');

    if (!results || results.length === 0) {
        resultsList.innerHTML = '<div class="no-results">No artist matches to display</div>';
        return;
    }

    // Filter results
    let filteredResults = results;
    if (filter !== 'all') {
        filteredResults = results.filter(r => r.category === filter || (filter === 'skipped' && (r.status === 'skipped' || r.status === 'error')));
    }

    let html = '<h3 style="margin-bottom: 15px;">Artist Match Results</h3>';

    for (const result of filteredResults) {
        const category = result.category || 'skipped';
        const confidenceBadge = result.confidence > 0 ?
            `<span class="format-badge" style="background-color: ${getConfidenceBadgeColor(result.confidence)};">${result.confidence}% match</span>` : '';

        const mbMatch = result.mbMatch;
        const matchInfo = mbMatch ?
            `<strong>MusicBrainz Match:</strong> ${mbMatch.artist}` :
            `<strong>Status:</strong> No match found`;

        // Determine if action buttons are needed
        const needsAction = (category === 'review' || category === 'manual');
        const actionButtons = needsAction ? `
            <div class="match-action-buttons">
                ${category === 'review' ? `<button class="action-btn accept-btn" data-phase="artist" data-index="${filteredResults.indexOf(result)}" title="Accept this match">✅ Accept</button>` : ''}
                <button class="action-btn search-btn" data-phase="artist" data-index="${filteredResults.indexOf(result)}" title="Search for a different match">🔍 Search</button>
                <button class="action-btn edit-btn" data-phase="artist" data-index="${filteredResults.indexOf(result)}" title="Manually edit metadata">✏️ Edit</button>
                <button class="action-btn skip-btn" data-phase="artist" data-index="${filteredResults.indexOf(result)}" title="Skip this artist">⏭️ Skip</button>
            </div>
        ` : '';

        const statusBadge = result.manualOverride ? '<span class="status-badge manual-override">MANUAL OVERRIDE</span>' :
                           result.accepted ? '<span class="status-badge accepted">ACCEPTED</span>' :
                           result.skipped ? '<span class="status-badge skipped">SKIPPED</span>' : '';

        html += `
            <div class="match-result-item ${category}" data-result-index="${filteredResults.indexOf(result)}">
                <div class="match-result-header">
                    <div class="match-result-info">
                        <h4 class="match-result-title">${result.originalArtist}</h4>
                        <div class="match-result-meta">
                            <strong>Files using this artist:</strong> ${result.fileCount}
                        </div>
                        <div class="match-result-meta" style="margin-top: 5px;">
                            ${matchInfo}
                        </div>
                    </div>
                    <div class="match-result-badges">
                        ${confidenceBadge}
                        ${statusBadge}
                    </div>
                </div>
                ${actionButtons}
            </div>
        `;
    }

    resultsList.innerHTML = html;
}

/**
 * Attach event listeners to artist match action buttons
 */
function attachArtistMatchActionListeners() {
    const resultsList = document.getElementById('matchResultsList');

    // Remove existing listener if any (to prevent duplicates)
    const oldListener = resultsList._artistMatchListener;
    if (oldListener) {
        resultsList.removeEventListener('click', oldListener);
    }

    // Create new listener function
    const listener = async (e) => {
        const target = e.target;

        // Accept button
        if (target.classList.contains('accept-btn') && target.dataset.phase === 'artist') {
            const index = parseInt(target.dataset.index);
            const result = artistMatchResults[index];
            result.accepted = true;
            console.log('[Matcher] Accepted artist match:', result);
            displayArtistMatchResults(artistMatchResults, 'all');
            attachArtistMatchActionListeners(); // Re-attach after redisplay
        }

        // Search button
        else if (target.classList.contains('search-btn') && target.dataset.phase === 'artist') {
            const index = parseInt(target.dataset.index);
            const result = artistMatchResults[index];
            console.log('[Matcher] Search for artist:', result.originalArtist);
            openArtistSearchModal(result, index);
        }

        // Edit button
        else if (target.classList.contains('edit-btn') && target.dataset.phase === 'artist') {
            const index = parseInt(target.dataset.index);
            const result = artistMatchResults[index];
            console.log('[Matcher] Edit artist:', result.originalArtist);
            openArtistEditModal(result, index);
        }

        // Skip button
        else if (target.classList.contains('skip-btn') && target.dataset.phase === 'artist') {
            const index = parseInt(target.dataset.index);
            const result = artistMatchResults[index];
            result.skipped = true;
            console.log('[Matcher] Skipped artist:', result.originalArtist);
            displayArtistMatchResults(artistMatchResults, 'all');
            attachArtistMatchActionListeners(); // Re-attach after redisplay
        }
    };

    // Store listener reference and attach it
    resultsList._artistMatchListener = listener;
    resultsList.addEventListener('click', listener);
}

/**
 * Open search modal for Phase 1 artist matching
 */
async function openArtistSearchModal(result, index) {
    const modal = document.getElementById('manualSearchModal');
    const searchArtistInput = document.getElementById('searchArtist');
    const searchAlbumInput = document.getElementById('searchAlbum');
    const searchTitleInput = document.getElementById('searchTitle');
    const searchButton = document.getElementById('performSearchBtn');
    const resultsContainer = document.getElementById('searchResultsContainer');
    const resultsList = document.getElementById('searchResultsList');

    // Pre-fill artist search field
    searchArtistInput.value = result.originalArtist;
    searchAlbumInput.value = '';
    searchTitleInput.value = '';

    // Hide album and title fields for artist search
    searchAlbumInput.parentElement.style.display = 'none';
    searchTitleInput.parentElement.style.display = 'none';

    resultsContainer.style.display = 'none';
    resultsList.innerHTML = '';

    // Show modal
    modal.style.display = 'block';

    // Remove old listener and create new one
    const newSearchButton = searchButton.cloneNode(true);
    searchButton.parentNode.replaceChild(newSearchButton, searchButton);

    // Search button handler
    newSearchButton.onclick = async () => {
        const query = searchArtistInput.value.trim();
        if (!query) return;

        resultsContainer.style.display = 'block';
        resultsList.innerHTML = '<div style="padding: 20px; text-align: center;">Searching MusicBrainz...</div>';

        try {
            const response = await fetch(`http://localhost:3000/api/musicbrainz/search-artist`, {
                method: 'POST',
                headers: { 'Content-Type': 'application/json' },
                body: JSON.stringify({ query, limit: 5 })
            });
            const data = await response.json();

            if (!data.results || data.results.length === 0) {
                resultsList.innerHTML = '<div style="padding: 20px; text-align: center;">No results found</div>';
                return;
            }

            let html = '';
            data.results.forEach((artist, i) => {
                html += `
                    <div class="search-result-item" data-index="${i}" style="padding: 15px; border-bottom: 1px solid #333; cursor: pointer; background: #1a1a1a; margin-bottom: 10px; border-radius: 5px;">
                        <div style="font-weight: bold; margin-bottom: 5px;">${artist.artist || 'Unknown Artist'}</div>
                        <div style="font-size: 0.9em; color: #888;">
                            Confidence: ${artist.confidence}%
                        </div>
                    </div>
                `;
            });
            resultsList.innerHTML = html;

            // Attach click handlers to search results
            resultsList.querySelectorAll('.search-result-item').forEach((item, i) => {
                item.addEventListener('click', () => {
                    const selectedArtist = data.results[i];
                    result.mbMatch = {
                        artist: selectedArtist.artist,
                        mbid: selectedArtist.mbid || ''
                    };
                    result.confidence = selectedArtist.confidence;
                    result.category = selectedArtist.confidence >= 90 ? 'auto_approve' :
                                    selectedArtist.confidence >= 70 ? 'review' : 'manual';
                    result.manualOverride = true;
                    result.accepted = true;

                    modal.style.display = 'none';
                    // Restore field visibility
                    searchAlbumInput.parentElement.style.display = 'block';
                    searchTitleInput.parentElement.style.display = 'block';
                    displayArtistMatchResults(artistMatchResults, 'all');
                    attachArtistMatchActionListeners();
                    addScanLog(`Updated artist match for "${result.originalArtist}" → "${selectedArtist.artist}"`, 'success');
                });
            });

        } catch (error) {
            console.error('[Search] Error:', error);
            resultsList.innerHTML = `<div style="padding: 20px; color: #e74c3c;">Error: ${error.message}</div>`;
        }
    };
}

/**
 * Open edit modal for Phase 1 artist matching
 */
function openArtistEditModal(result, index) {
    const modal = document.getElementById('metadataEditorModal');
    const saveButton = document.getElementById('saveMetadataBtn');

    // Populate form with current data
    document.getElementById('editArtist').value = result.mbMatch?.artist || result.originalArtist;
    document.getElementById('editAlbum').value = '';
    document.getElementById('editTitle').value = '';
    document.getElementById('editYear').value = '';
    document.getElementById('editTrack').value = '';

    // Hide album, title, year, track fields for artist matching
    document.getElementById('editAlbum').parentElement.style.display = 'none';
    document.getElementById('editTitle').parentElement.style.display = 'none';
    document.getElementById('editYear').parentElement.style.display = 'none';
    document.getElementById('editTrack').parentElement.style.display = 'none';

    // Show modal
    modal.style.display = 'block';

    // Remove old listener and create new one
    const newSaveButton = saveButton.cloneNode(true);
    saveButton.parentNode.replaceChild(newSaveButton, saveButton);

    // Save button handler
    newSaveButton.onclick = (e) => {
        e.preventDefault();

        const newArtist = document.getElementById('editArtist').value.trim();

        if (!newArtist) {
            alert('Artist name cannot be empty');
            return;
        }

        // Update the match result
        result.mbMatch = {
            artist: newArtist,
            mbid: ''
        };
        result.confidence = 100;
        result.category = 'auto_approve';
        result.manualOverride = true;
        result.accepted = true;

        modal.style.display = 'none';
        // Restore field visibility
        document.getElementById('editAlbum').parentElement.style.display = 'block';
        document.getElementById('editTitle').parentElement.style.display = 'block';
        document.getElementById('editYear').parentElement.style.display = 'block';
        document.getElementById('editTrack').parentElement.style.display = 'block';
        displayArtistMatchResults(artistMatchResults, 'all');
        attachArtistMatchActionListeners();
        addScanLog(`Manually edited artist: "${result.originalArtist}" → "${newArtist}"`, 'success');
    };
}

// =====================================================
// PHASE 2: ALBUM MATCHING ACTION HANDLERS
// =====================================================

/**
 * Attach event listeners to Phase 2 album match action buttons using event delegation
 */
function attachAlbumMatchActionListeners() {
    const resultsList = document.getElementById('matchResultsList');

    // Remove existing listener if any (to prevent duplicates)
    const oldListener = resultsList._albumMatchListener;
    if (oldListener) {
        resultsList.removeEventListener('click', oldListener);
    }

    // Create new listener function
    const listener = async (e) => {
        const target = e.target;

        // Accept button
        if (target.classList.contains('accept-btn') && target.dataset.phase === 'album') {
            const index = parseInt(target.dataset.index);
            const result = albumMatchResults[index];
            result.accepted = true;
            console.log('[Matcher] Accepted album match:', result);
            displayAlbumMatchResults(albumMatchResults, 'all');
            attachAlbumMatchActionListeners(); // Re-attach after redisplay
        }

        // Search button
        else if (target.classList.contains('search-btn') && target.dataset.phase === 'album') {
            const index = parseInt(target.dataset.index);
            const result = albumMatchResults[index];
            console.log('[Matcher] Search for album:', result.originalAlbum);
            openAlbumSearchModal(result, index);
        }

        // Edit button
        else if (target.classList.contains('edit-btn') && target.dataset.phase === 'album') {
            const index = parseInt(target.dataset.index);
            const result = albumMatchResults[index];
            console.log('[Matcher] Edit album:', result.originalAlbum);
            openAlbumEditModal(result, index);
        }

        // Skip button
        else if (target.classList.contains('skip-btn') && target.dataset.phase === 'album') {
            const index = parseInt(target.dataset.index);
            const result = albumMatchResults[index];
            result.skipped = true;
            console.log('[Matcher] Skipped album:', result.originalAlbum);
            displayAlbumMatchResults(albumMatchResults, 'all');
            attachAlbumMatchActionListeners(); // Re-attach after redisplay
        }
    };

    // Store listener reference and attach it
    resultsList._albumMatchListener = listener;
    resultsList.addEventListener('click', listener);
}

/**
 * Open search modal for Phase 2 album matching
 */
async function openAlbumSearchModal(result, index) {
    const modal = document.getElementById('searchModal');
    const modalTitle = document.getElementById('searchModalTitle');
    const searchInput = document.getElementById('manualSearchInput');
    const searchButton = document.getElementById('manualSearchButton');
    const resultsDiv = document.getElementById('manualSearchResults');

    modalTitle.textContent = `Search for Album: ${result.originalAlbum} by ${result.originalArtist}`;
    searchInput.value = `${result.originalArtist} ${result.originalAlbum}`;
    resultsDiv.innerHTML = '';

    // Show modal
    modal.style.display = 'block';

    // Search button handler
    searchButton.onclick = async () => {
        const query = searchInput.value.trim();
        if (!query) return;

        resultsDiv.innerHTML = '<div style="padding: 20px; text-align: center;">Searching MusicBrainz...</div>';

        try {
            const response = await fetch(`http://localhost:3000/api/musicbrainz/search-album`, {
                method: 'POST',
                headers: { 'Content-Type': 'application/json' },
                body: JSON.stringify({ query, limit: 5 })
            });
            const data = await response.json();

            if (!data.results || data.results.length === 0) {
                resultsDiv.innerHTML = '<div style="padding: 20px; text-align: center;">No results found</div>';
                return;
            }

            let html = '<div class="search-results-list">';
            data.results.forEach((album, i) => {
                html += `
                    <div class="search-result-item" data-index="${i}" style="padding: 15px; border-bottom: 1px solid #333; cursor: pointer;">
                        <div style="font-weight: bold; margin-bottom: 5px;">${album.album || 'Unknown Album'}</div>
                        <div style="font-size: 0.9em; color: #bbb; margin-bottom: 3px;">by ${album.artist || 'Unknown Artist'}</div>
                        <div style="font-size: 0.9em; color: #888;">
                            Confidence: ${album.confidence}%
                        </div>
                    </div>
                `;
            });
            html += '</div>';
            resultsDiv.innerHTML = html;

            // Attach click handlers to search results
            resultsDiv.querySelectorAll('.search-result-item').forEach((item, i) => {
                item.addEventListener('click', () => {
                    const selectedAlbum = data.results[i];
                    result.mbMatch = {
                        artist: selectedAlbum.artist,
                        album: selectedAlbum.album,
                        mbid: selectedAlbum.mbid || ''
                    };
                    result.confidence = selectedAlbum.confidence;
                    result.category = selectedAlbum.confidence >= 90 ? 'auto_approve' :
                                    selectedAlbum.confidence >= 70 ? 'review' : 'manual';
                    result.manualOverride = true;
                    result.accepted = true;

                    modal.style.display = 'none';
                    displayAlbumMatchResults(albumMatchResults, 'all');
                    attachAlbumMatchActionListeners();
                    addScanLog(`Updated album match for "${result.originalAlbum}" → "${selectedAlbum.artist} - ${selectedAlbum.album}"`, 'success');
                });
            });

        } catch (error) {
            console.error('[Search] Error:', error);
            resultsDiv.innerHTML = `<div style="padding: 20px; color: #e74c3c;">Error: ${error.message}</div>`;
        }
    };

    // Close modal handlers
    document.getElementById('closeSearchModal').onclick = () => {
        modal.style.display = 'none';
    };
    window.onclick = (e) => {
        if (e.target === modal) {
            modal.style.display = 'none';
        }
    };
}

/**
 * Open edit modal for Phase 2 album matching
 */
function openAlbumEditModal(result, index) {
    const modal = document.getElementById('editModal');
    const modalTitle = document.getElementById('editModalTitle');
    const form = document.getElementById('editMetadataForm');

    modalTitle.textContent = `Edit Album: ${result.originalAlbum} by ${result.originalArtist}`;

    // Populate form with current data
    document.getElementById('editArtist').value = result.mbMatch?.artist || result.originalArtist;
    document.getElementById('editAlbum').value = result.mbMatch?.album || result.originalAlbum;

    // Show artist and album fields, hide track-specific fields
    document.getElementById('editArtistGroup').style.display = 'block';
    document.getElementById('editAlbumGroup').style.display = 'block';
    document.getElementById('editTitleGroup').style.display = 'none';
    document.getElementById('editYearGroup').style.display = 'none';
    document.getElementById('editTrackNumberGroup').style.display = 'none';

    // Show modal
    modal.style.display = 'block';

    // Save button handler
    form.onsubmit = (e) => {
        e.preventDefault();

        const newArtist = document.getElementById('editArtist').value.trim();
        const newAlbum = document.getElementById('editAlbum').value.trim();

        if (!newArtist || !newAlbum) {
            alert('Artist and Album names cannot be empty');
            return;
        }

        // Update the match result
        result.mbMatch = {
            artist: newArtist,
            album: newAlbum,
            mbid: ''
        };
        result.confidence = 100;
        result.category = 'auto_approve';
        result.manualOverride = true;
        result.accepted = true;

        modal.style.display = 'none';
        displayAlbumMatchResults(albumMatchResults, 'all');
        attachAlbumMatchActionListeners();
        addScanLog(`Manually edited album: "${result.originalAlbum}" → "${newArtist} - ${newAlbum}"`, 'success');
    };

    // Close modal handlers
    document.getElementById('closeEditModal').onclick = () => {
        modal.style.display = 'none';
    };
    window.onclick = (e) => {
        if (e.target === modal) {
            modal.style.display = 'none';
        }
    };
}

/**
 * Display Phase 2 album match results
 */
function displayAlbumMatchResults(results, filter = 'all') {
    const resultsList = document.getElementById('matchResultsList');

    if (!results || results.length === 0) {
        resultsList.innerHTML = '<div class="no-results">No album matches to display</div>';
        return;
    }

    // Filter results
    let filteredResults = results;
    if (filter !== 'all') {
        filteredResults = results.filter(r => r.category === filter || (filter === 'skipped' && (r.status === 'skipped' || r.status === 'error')));
    }

    let html = '<h3 style="margin-bottom: 15px;">Album Match Results</h3>';

    for (const result of filteredResults) {
        const category = result.category || 'skipped';
        const confidenceBadge = result.confidence > 0 ?
            `<span class="format-badge" style="background-color: ${getConfidenceBadgeColor(result.confidence)};">${result.confidence}% match</span>` : '';

        const mbMatch = result.mbMatch;
        const matchInfo = mbMatch ?
            `<strong>MusicBrainz Match:</strong> ${mbMatch.artist} - ${mbMatch.album}` :
            `<strong>Status:</strong> No match found`;

        // Determine if action buttons are needed
        const needsAction = (category === 'review' || category === 'manual');
        const actionButtons = needsAction ? `
            <div class="match-action-buttons">
                ${category === 'review' ? `<button class="action-btn accept-btn" data-phase="album" data-index="${filteredResults.indexOf(result)}" title="Accept this match">✅ Accept</button>` : ''}
                <button class="action-btn search-btn" data-phase="album" data-index="${filteredResults.indexOf(result)}" title="Search for a different match">🔍 Search</button>
                <button class="action-btn edit-btn" data-phase="album" data-index="${filteredResults.indexOf(result)}" title="Manually edit metadata">✏️ Edit</button>
                <button class="action-btn skip-btn" data-phase="album" data-index="${filteredResults.indexOf(result)}" title="Skip this album">⏭️ Skip</button>
            </div>
        ` : '';

        const statusBadge = result.manualOverride ? '<span class="status-badge manual-override">MANUAL OVERRIDE</span>' :
                           result.accepted ? '<span class="status-badge accepted">ACCEPTED</span>' :
                           result.skipped ? '<span class="status-badge skipped">SKIPPED</span>' : '';

        html += `
            <div class="match-result-item ${category}" data-result-index="${filteredResults.indexOf(result)}">
                <div class="match-result-header">
                    <div class="match-result-info">
                        <h4 class="match-result-title">${result.originalAlbum}</h4>
                        <div class="match-result-meta">
                            <strong>Original Artist:</strong> ${result.originalArtist}
                        </div>
                        <div class="match-result-meta">
                            <strong>Files in this album:</strong> ${result.fileCount}
                        </div>
                        <div class="match-result-meta" style="margin-top: 5px;">
                            ${matchInfo}
                        </div>
                    </div>
                    <div class="match-result-badges">
                        ${confidenceBadge}
                        ${statusBadge}
                    </div>
                </div>
                ${actionButtons}
            </div>
        `;
    }

    resultsList.innerHTML = html;
}

/**
 * Display match results with filtering
 */
function displayMatchResults(results, filter = 'all') {
    const resultsList = document.getElementById('matchResultsList');

    if (!results || results.length === 0) {
        resultsList.innerHTML = '<div class="no-results">No match results to display</div>';
        return;
    }

    // Filter results
    let filteredResults = results;
    if (filter !== 'all') {
        filteredResults = results.filter(r => r.category === filter || (filter === 'skipped' && (r.status === 'skipped' || r.status === 'error' || r.status === 'no_match')));
    }

    let html = '';

    for (const result of filteredResults) {
        const category = result.category || 'skipped';
        const confidenceBadge = result.confidence > 0 ?
            `<span class="format-badge" style="background-color: ${getConfidenceBadgeColor(result.confidence)};">${result.confidence}% match</span>` : '';

        const mbMatch = result.mbMatch;
        const matchInfo = mbMatch ?
            `<strong>MusicBrainz Match:</strong> ${mbMatch.artist} - ${mbMatch.title}` :
            `<strong>Status:</strong> ${result.reason || 'No match found'}`;

        // Determine if action buttons are needed
        const needsAction = (category === 'review' || category === 'manual');
        const actionButtons = needsAction ? `
            <div class="match-action-buttons">
                ${category === 'review' ? `<button class="action-btn accept-btn" data-phase="track" data-index="${filteredResults.indexOf(result)}" title="Accept this match">✅ Accept</button>` : ''}
                <button class="action-btn search-btn" data-phase="track" data-index="${filteredResults.indexOf(result)}" title="Search for a different match">🔍 Search</button>
                <button class="action-btn edit-btn" data-phase="track" data-index="${filteredResults.indexOf(result)}" title="Manually edit metadata">✏️ Edit</button>
                <button class="action-btn skip-btn" data-phase="track" data-index="${filteredResults.indexOf(result)}" title="Skip this file">⏭️ Skip</button>
            </div>
        ` : '';

        // Check for manual override or acceptance status
        const statusBadge = result.manualOverride ? '<span class="status-badge manual-override">MANUAL OVERRIDE</span>' :
                           result.accepted ? '<span class="status-badge accepted">ACCEPTED</span>' :
                           result.skipped ? '<span class="status-badge skipped">SKIPPED</span>' : '';

        html += `
            <div class="match-result-item ${category}" data-result-index="${filteredResults.indexOf(result)}">
                <div class="match-result-header">
                    <div class="match-result-info">
                        <h4 class="match-result-title">${result.originalMetadata.title || 'Unknown Title'}</h4>
                        <div class="match-result-meta">
                            <strong>Original:</strong> ${result.originalMetadata.artist || 'Unknown'} - ${result.originalMetadata.album || 'Unknown'}
                        </div>
                        <div class="match-result-meta" style="margin-top: 5px;">
                            ${matchInfo}
                        </div>
                    </div>
                </div>
                <div class="match-result-badges">
                    ${confidenceBadge}
                    <span class="format-badge">${result.category === 'auto_approve' ? 'Auto-Approved' : result.category === 'review' ? 'Review' : result.category === 'manual' ? 'Manual' : 'Skipped'}</span>
                    ${result.fileInfo ? `<span class="format-badge">${result.fileInfo.codec || result.fileInfo.format}</span>` : ''}
                    ${result.searchMethod && result.searchMethod !== 'original' ? `<span class="format-badge" style="background-color: #9b59b6;" title="Match found using ${result.searchMethod} conversion">🇯🇵 ${result.searchMethod.toUpperCase()}</span>` : ''}
                    ${statusBadge}
                </div>
                ${actionButtons}
            </div>
        `;
    }

    resultsList.innerHTML = html || '<div class="no-results">No results match this filter</div>';

    // Attach event listeners to action buttons
    attachTrackMatchActionListeners();
}

// =====================================================
// PHASE 3: TRACK MATCHING ACTION HANDLERS
// =====================================================

/**
 * Attach event listeners to Phase 3 track match action buttons using event delegation
 */
function attachTrackMatchActionListeners() {
    const resultsList = document.getElementById('matchResultsList');

    // Remove existing listener if any (to prevent duplicates)
    const oldListener = resultsList._trackMatchListener;
    if (oldListener) {
        resultsList.removeEventListener('click', oldListener);
    }

    // Create new listener function
    const listener = async (e) => {
        const target = e.target;

        // Accept button
        if (target.classList.contains('accept-btn') && target.dataset.phase === 'track') {
            const index = parseInt(target.dataset.index);
            await handleAcceptMatch(index);
        }

        // Search button
        else if (target.classList.contains('search-btn') && target.dataset.phase === 'track') {
            const index = parseInt(target.dataset.index);
            const result = matchResults[index];
            console.log('[Matcher] Search for track:', result.originalMetadata.title);
            openTrackSearchModal(result, index);
        }

        // Edit button
        else if (target.classList.contains('edit-btn') && target.dataset.phase === 'track') {
            const index = parseInt(target.dataset.index);
            const result = matchResults[index];
            console.log('[Matcher] Edit track:', result.originalMetadata.title);
            openTrackEditModal(result, index);
        }

        // Skip button
        else if (target.classList.contains('skip-btn') && target.dataset.phase === 'track') {
            const index = parseInt(target.dataset.index);
            await handleSkipMatch(index);
        }
    };

    // Store listener reference and attach it
    resultsList._trackMatchListener = listener;
    resultsList.addEventListener('click', listener);
}

/**
 * Open search modal for Phase 3 track matching
 */
async function openTrackSearchModal(result, index) {
    const modal = document.getElementById('searchModal');
    const modalTitle = document.getElementById('searchModalTitle');
    const searchInput = document.getElementById('manualSearchInput');
    const searchButton = document.getElementById('manualSearchButton');
    const resultsDiv = document.getElementById('manualSearchResults');

    modalTitle.textContent = `Search for Track: ${result.originalMetadata.title}`;
    searchInput.value = `${result.originalMetadata.artist} ${result.originalMetadata.title}`;
    resultsDiv.innerHTML = '';

    // Show modal
    modal.style.display = 'block';

    // Search button handler
    searchButton.onclick = async () => {
        const query = searchInput.value.trim();
        if (!query) return;

        resultsDiv.innerHTML = '<div style="padding: 20px; text-align: center;">Searching MusicBrainz...</div>';

        try {
            const response = await fetch(`http://localhost:3000/api/musicbrainz/search`, {
                method: 'POST',
                headers: { 'Content-Type': 'application/json' },
                body: JSON.stringify({ query, limit: 5 })
            });
            const data = await response.json();

            if (!data.results || data.results.length === 0) {
                resultsDiv.innerHTML = '<div style="padding: 20px; text-align: center;">No results found</div>';
                return;
            }

            let html = '<div class="search-results-list">';
            data.results.forEach((track, i) => {
                html += `
                    <div class="search-result-item" data-index="${i}" style="padding: 15px; border-bottom: 1px solid #333; cursor: pointer;">
                        <div style="font-weight: bold; margin-bottom: 5px;">${track.title || 'Unknown Title'}</div>
                        <div style="font-size: 0.9em; color: #bbb; margin-bottom: 3px;">by ${track.artist || 'Unknown Artist'}</div>
                        <div style="font-size: 0.9em; color: #999; margin-bottom: 3px;">Album: ${track.album || 'Unknown Album'}</div>
                        <div style="font-size: 0.9em; color: #888;">
                            Confidence: ${track.confidence}%${track.year ? ` • ${track.year}` : ''}
                        </div>
                    </div>
                `;
            });
            html += '</div>';
            resultsDiv.innerHTML = html;

            // Attach click handlers to search results
            resultsDiv.querySelectorAll('.search-result-item').forEach((item, i) => {
                item.addEventListener('click', () => {
                    const selectedTrack = data.results[i];
                    result.mbMatch = {
                        artist: selectedTrack.artist,
                        album: selectedTrack.album,
                        title: selectedTrack.title,
                        year: selectedTrack.year || '',
                        mbid: selectedTrack.mbid || ''
                    };
                    result.confidence = selectedTrack.confidence;
                    result.category = selectedTrack.confidence >= 90 ? 'auto_approve' :
                                    selectedTrack.confidence >= 70 ? 'review' : 'manual';
                    result.manualOverride = true;
                    result.accepted = true;

                    modal.style.display = 'none';
                    displayMatchResults(matchResults, 'all');
                    attachTrackMatchActionListeners();
                    addScanLog(`Updated track match for "${result.originalMetadata.title}" → "${selectedTrack.artist} - ${selectedTrack.title}"`, 'success');
                });
            });

        } catch (error) {
            console.error('[Search] Error:', error);
            resultsDiv.innerHTML = `<div style="padding: 20px; color: #e74c3c;">Error: ${error.message}</div>`;
        }
    };

    // Close modal handlers
    document.getElementById('closeSearchModal').onclick = () => {
        modal.style.display = 'none';
    };
    window.onclick = (e) => {
        if (e.target === modal) {
            modal.style.display = 'none';
        }
    };
}

/**
 * Open edit modal for Phase 3 track matching
 */
function openTrackEditModal(result, index) {
    const modal = document.getElementById('editModal');
    const modalTitle = document.getElementById('editModalTitle');
    const form = document.getElementById('editMetadataForm');

    modalTitle.textContent = `Edit Track: ${result.originalMetadata.title}`;

    // Populate form with current data
    document.getElementById('editArtist').value = result.mbMatch?.artist || result.originalMetadata.artist || '';
    document.getElementById('editAlbum').value = result.mbMatch?.album || result.originalMetadata.album || '';
    document.getElementById('editTitle').value = result.mbMatch?.title || result.originalMetadata.title || '';
    document.getElementById('editYear').value = result.mbMatch?.year || result.originalMetadata.year || '';
    document.getElementById('editTrackNumber').value = result.mbMatch?.trackNumber || result.originalMetadata.trackNumber || '';

    // Show all fields for track editing
    document.getElementById('editArtistGroup').style.display = 'block';
    document.getElementById('editAlbumGroup').style.display = 'block';
    document.getElementById('editTitleGroup').style.display = 'block';
    document.getElementById('editYearGroup').style.display = 'block';
    document.getElementById('editTrackNumberGroup').style.display = 'block';

    // Show modal
    modal.style.display = 'block';

    // Save button handler
    form.onsubmit = (e) => {
        e.preventDefault();

        const newArtist = document.getElementById('editArtist').value.trim();
        const newAlbum = document.getElementById('editAlbum').value.trim();
        const newTitle = document.getElementById('editTitle').value.trim();
        const newYear = document.getElementById('editYear').value.trim();
        const newTrackNumber = document.getElementById('editTrackNumber').value.trim();

        if (!newArtist || !newAlbum || !newTitle) {
            alert('Artist, Album, and Title cannot be empty');
            return;
        }

        // Update the match result
        result.mbMatch = {
            artist: newArtist,
            album: newAlbum,
            title: newTitle,
            year: newYear,
            trackNumber: newTrackNumber,
            mbid: ''
        };
        result.confidence = 100;
        result.category = 'auto_approve';
        result.manualOverride = true;
        result.accepted = true;

        modal.style.display = 'none';
        displayMatchResults(matchResults, 'all');
        attachTrackMatchActionListeners();
        addScanLog(`Manually edited track: "${result.originalMetadata.title}" → "${newArtist} - ${newTitle}"`, 'success');
    };

    // Close modal handlers
    document.getElementById('closeEditModal').onclick = () => {
        modal.style.display = 'none';
    };
    window.onclick = (e) => {
        if (e.target === modal) {
            modal.style.display = 'none';
        }
    };
}

/**
 * Handle Accept Match action
 */
async function handleAcceptMatch(index) {
    console.log(`[Review] Accepting match at index ${index}`);

    if (!matchResults || index < 0 || index >= matchResults.length) {
        addScanLog('Invalid match index', 'error');
        return;
    }

    const result = matchResults[index];

    // Mark as accepted
    result.accepted = true;
    result.category = 'auto_approve'; // Promote to auto-approve
    result.confidence = 100; // Set confidence to 100%

    addScanLog(`Accepted match: ${result.originalMetadata.title} → ${result.mbMatch.artist} - ${result.mbMatch.title}`, 'success');

    // Refresh display
    displayMatchResults(matchResults, 'all');
    displayMatchStatistics(calculateMatchStatistics(matchResults));
}

/**
 * Handle Skip Match action
 */
async function handleSkipMatch(index) {
    console.log(`[Review] Skipping match at index ${index}`);

    if (!matchResults || index < 0 || index >= matchResults.length) {
        addScanLog('Invalid match index', 'error');
        return;
    }

    const result = matchResults[index];

    // Mark as skipped
    result.skipped = true;
    result.status = 'skipped';
    result.category = 'skipped';

    addScanLog(`Skipped: ${result.originalMetadata.title}`, 'warning');

    // Refresh display
    displayMatchResults(matchResults, 'all');
    displayMatchStatistics(calculateMatchStatistics(matchResults));
}

/**
 * Calculate match statistics from current results
 */
function calculateMatchStatistics(results) {
    const stats = {
        total: results.length,
        matched: 0,
        skipped: 0,
        errors: 0,
        byCategory: {
            auto_approve: 0,
            review: 0,
            manual: 0
        }
    };

    results.forEach(r => {
        if (r.status === 'skipped' || r.skipped) {
            stats.skipped++;
        } else if (r.status === 'error') {
            stats.errors++;
        } else if (r.mbMatch) {
            stats.matched++;
        }

        if (r.category === 'auto_approve') stats.byCategory.auto_approve++;
        else if (r.category === 'review') stats.byCategory.review++;
        else if (r.category === 'manual') stats.byCategory.manual++;
    });

    return stats;
}

/**
 * Handle Manual Search action
 */
async function handleManualSearch(index) {
    console.log(`[Review] Opening manual search for index ${index}`);

    if (!matchResults || index < 0 || index >= matchResults.length) {
        addScanLog('Invalid match index', 'error');
        return;
    }

    const result = matchResults[index];
    showManualSearchModal(result, index);
}

/**
 * Handle Edit Metadata action
 */
async function handleEditMetadata(index) {
    console.log(`[Review] Opening metadata editor for index ${index}`);

    if (!matchResults || index < 0 || index >= matchResults.length) {
        addScanLog('Invalid match index', 'error');
        return;
    }

    const result = matchResults[index];
    showMetadataEditorModal(result, index);
}

/**
 * Show manual search modal
 */
function showManualSearchModal(result, resultIndex) {
    const modal = document.getElementById('manualSearchModal');
    if (!modal) {
        console.error('[Review] Manual search modal not found');
        return;
    }

    // Populate search fields with current metadata
    document.getElementById('searchArtist').value = result.originalMetadata.artist || '';
    document.getElementById('searchAlbum').value = result.originalMetadata.album || '';
    document.getElementById('searchTitle').value = result.originalMetadata.title || '';

    // Store result index for later use
    modal.dataset.resultIndex = resultIndex;

    // Show modal
    modal.style.display = 'flex';
}

/**
 * Show metadata editor modal
 */
function showMetadataEditorModal(result, resultIndex) {
    const modal = document.getElementById('metadataEditorModal');
    if (!modal) {
        console.error('[Review] Metadata editor modal not found');
        return;
    }

    // Populate form fields with current metadata
    document.getElementById('editArtist').value = result.mbMatch?.artist || result.originalMetadata.artist || '';
    document.getElementById('editAlbum').value = result.mbMatch?.album || result.originalMetadata.album || '';
    document.getElementById('editTitle').value = result.mbMatch?.title || result.originalMetadata.title || '';
    document.getElementById('editYear').value = result.mbMatch?.year || result.fileInfo?.year || '';
    document.getElementById('editTrack').value = result.mbMatch?.trackNumber || result.fileInfo?.trackNumber || '';

    // Store result index for later use
    modal.dataset.resultIndex = resultIndex;

    // Show modal
    modal.style.display = 'flex';
}

/**
 * Setup modal event listeners (called once on init)
 */
function setupModalEventListeners() {
    // Manual Search Modal - Perform Search button
    const performSearchBtn = document.getElementById('performSearchBtn');
    if (performSearchBtn) {
        performSearchBtn.addEventListener('click', handlePerformManualSearch);
    }

    // Metadata Editor Modal - Save button
    const saveMetadataBtn = document.getElementById('saveMetadataBtn');
    if (saveMetadataBtn) {
        saveMetadataBtn.addEventListener('click', handleSaveMetadata);
    }
}

/**
 * Handle manual search execution
 */
async function handlePerformManualSearch() {
    const modal = document.getElementById('manualSearchModal');
    const resultIndex = parseInt(modal.dataset.resultIndex);

    const artist = document.getElementById('searchArtist').value.trim();
    const album = document.getElementById('searchAlbum').value.trim();
    const title = document.getElementById('searchTitle').value.trim();

    if (!artist || !title) {
        addScanLog('Artist and Title are required for search', 'error');
        return;
    }

    console.log('[Review] Performing manual search:', { artist, album, title });

    const searchBtn = document.getElementById('performSearchBtn');
    searchBtn.disabled = true;
    searchBtn.textContent = 'Searching...';

    try {
        // Call MusicBrainz search API
        const response = await fetch(`http://localhost:3000/api/musicbrainz/recording?artist=${encodeURIComponent(artist)}&title=${encodeURIComponent(title)}&album=${encodeURIComponent(album)}`);
        const data = await response.json();

        if (data.success && data.results && data.results.length > 0) {
            displayManualSearchResults(data.results, resultIndex);
            document.getElementById('searchResultsContainer').style.display = 'block';
            addScanLog(`Found ${data.results.length} results from MusicBrainz`, 'success');
        } else {
            document.getElementById('searchResultsList').innerHTML = '<div class="no-results">No results found. Try adjusting your search terms.</div>';
            document.getElementById('searchResultsContainer').style.display = 'block';
            addScanLog('No results found in MusicBrainz', 'warning');
        }
    } catch (error) {
        console.error('[Review] Manual search error:', error);
        addScanLog(`Search error: ${error.message}`, 'error');
        document.getElementById('searchResultsList').innerHTML = `<div class="error">Error: ${error.message}</div>`;
        document.getElementById('searchResultsContainer').style.display = 'block';
    } finally {
        searchBtn.disabled = false;
        searchBtn.textContent = 'Search MusicBrainz';
    }
}

/**
 * Display manual search results in modal
 */
function displayManualSearchResults(results, resultIndex) {
    const container = document.getElementById('searchResultsList');
    let html = '';

    results.slice(0, 10).forEach((result, index) => {
        html += `
            <div class="search-result-item" data-search-index="${index}">
                <div class="search-result-title">${result.title || 'Unknown Title'}</div>
                <div class="search-result-meta">
                    Artist: ${result.artist || 'Unknown'} | Album: ${result.album || 'N/A'} | Year: ${result.year || 'N/A'}
                </div>
            </div>
        `;
    });

    container.innerHTML = html;

    // Add click handlers for search results
    container.querySelectorAll('.search-result-item').forEach((item, index) => {
        item.addEventListener('click', () => {
            // Remove previous selection
            container.querySelectorAll('.search-result-item').forEach(i => i.classList.remove('selected'));
            // Mark as selected
            item.classList.add('selected');
            // Apply this result to the match
            applyManualSearchResult(results[index], resultIndex);
        });
    });
}

/**
 * Apply selected manual search result to match
 */
function applyManualSearchResult(searchResult, resultIndex) {
    console.log('[Review] Applying manual search result:', searchResult);

    if (!matchResults || resultIndex < 0 || resultIndex >= matchResults.length) {
        addScanLog('Invalid match index', 'error');
        return;
    }

    const result = matchResults[resultIndex];

    // Update match with new MusicBrainz data
    result.mbMatch = {
        artist: searchResult.artist || '',
        album: searchResult.album || '',
        title: searchResult.title || '',
        year: searchResult.year || '',
        trackNumber: searchResult.trackNumber || result.fileInfo?.trackNumber || 0,
        mbid: searchResult.mbid || ''
    };

    // Mark as manually searched and accepted
    result.manualOverride = true;
    result.accepted = true;
    result.category = 'auto_approve';
    result.confidence = 100;

    addScanLog(`Applied manual match: ${result.originalMetadata.title} → ${searchResult.artist} - ${searchResult.title}`, 'success');

    // Close modal
    document.getElementById('manualSearchModal').style.display = 'none';

    // Refresh display
    displayMatchResults(matchResults, 'all');
    displayMatchStatistics(calculateMatchStatistics(matchResults));
}

/**
 * Handle save metadata
 */
async function handleSaveMetadata() {
    const modal = document.getElementById('metadataEditorModal');
    const resultIndex = parseInt(modal.dataset.resultIndex);

    const artist = document.getElementById('editArtist').value.trim();
    const album = document.getElementById('editAlbum').value.trim();
    const title = document.getElementById('editTitle').value.trim();
    const year = document.getElementById('editYear').value.trim();
    const trackNumber = document.getElementById('editTrack').value.trim();

    if (!artist || !album || !title) {
        addScanLog('Artist, Album, and Title are required', 'error');
        return;
    }

    console.log('[Review] Saving manual metadata:', { artist, album, title, year, trackNumber });

    if (!matchResults || resultIndex < 0 || resultIndex >= matchResults.length) {
        addScanLog('Invalid match index', 'error');
        return;
    }

    const result = matchResults[resultIndex];

    // Update match with manual metadata
    result.mbMatch = {
        artist: artist,
        album: album,
        title: title,
        year: year ? parseInt(year) : 0,
        trackNumber: trackNumber ? parseInt(trackNumber) : result.fileInfo?.trackNumber || 0,
        mbid: '' // No MBID for manual entries
    };

    // Mark as manual override and accepted
    result.manualOverride = true;
    result.accepted = true;
    result.category = 'auto_approve';
    result.confidence = 100;

    addScanLog(`Manual metadata saved: ${result.originalMetadata.title} → ${artist} - ${title}`, 'success');

    // Close modal
    modal.style.display = 'none';

    // Refresh display
    displayMatchResults(matchResults, 'all');
    displayMatchStatistics(calculateMatchStatistics(matchResults));
}

/**
 * Handle Preview Renames button click
 */
async function handlePreviewRenames() {
    console.log('[Matcher] Generating rename previews...');

    if (!matchResults || matchResults.length === 0) {
        addScanLog('No match results to preview. Please run batch match first.', 'error');
        return;
    }

    // Use the scanned music path as the base directory for in-place renaming
    const musicPathInput = organizerElements.musicPathInput;
    const basePath = musicPathInput?.value?.trim();

    if (!basePath) {
        addScanLog('Music path not found. Please scan directory first.', 'error');
        return;
    }

    const previewBtn = document.getElementById('previewRenamesBtn');
    previewBtn.disabled = true;

    addScanLog('Generating rename preview for in-place reorganization...', 'info');

    try {
        const response = await fetch('http://localhost:3000/api/matcher/preview-rename', {
            method: 'POST',
            headers: { 'Content-Type': 'application/json' },
            body: JSON.stringify({
                matchResults: matchResults,
                basePath: basePath
            })
        });

        const result = await response.json();

        if (result.success) {
            renamePreviews = result.previews;
            console.log('[Matcher] Rename previews generated:', renamePreviews);

            displayRenamePreviews(renamePreviews);
            document.getElementById('renamePreviewContainer').style.display = 'block';

            addScanLog(`Rename preview generated: ${renamePreviews.summary.autoApprove + renamePreviews.summary.review} files ready to rename`, 'success');

            // Scroll to rename preview (increased delay for DOM to update)
            setTimeout(() => scrollToElement('#renamePreviewContainer'), 400);
        } else {
            addScanLog(`Preview error: ${result.error}`, 'error');
        }
    } catch (error) {
        console.error('[Matcher] Preview error:', error);
        addScanLog(`Preview error: ${error.message}`, 'error');
    } finally {
        previewBtn.disabled = false;
    }
}

/**
 * Display rename previews
 */
function displayRenamePreviews(previews) {
    const previewList = document.getElementById('renamePreviewList');

    if (!previews) {
        previewList.innerHTML = '<div class="no-results">No previews to display</div>';
        return;
    }

    // Combine auto_approve and review items (skip manual and skipped for rename)
    const itemsToRename = [...previews.auto_approve, ...previews.review];

    if (itemsToRename.length === 0) {
        previewList.innerHTML = '<div class="no-results">No files ready to rename</div>';
        return;
    }

    let html = '';

    for (const item of itemsToRename.slice(0, 50)) { // Limit to first 50 for performance
        if (!item.renamePreview || !item.renamePreview.changed) continue;

        html += `
            <div class="rename-preview-item">
                <div class="rename-preview-path original">
                    <strong>Current:</strong> ${item.renamePreview.originalPath}
                </div>
                <div class="rename-preview-arrow">↓</div>
                <div class="rename-preview-path proposed">
                    <strong>Proposed:</strong> ${item.renamePreview.proposedPath}
                </div>
            </div>
        `;
    }

    if (itemsToRename.length > 50) {
        html += `<div class="no-results">... and ${itemsToRename.length - 50} more files</div>`;
    }

    previewList.innerHTML = html;
}

/**
 * Handle Execute Rename button click
 */
async function handleExecuteRename(dryRun = true) {
    console.log(`[Matcher] Executing rename (dryRun: ${dryRun})...`);

    if (!renamePreviews) {
        addScanLog('No rename previews available. Please click "Preview Renames" first.', 'error');
        return;
    }

    // Combine auto_approve and review items
    const itemsToRename = [...renamePreviews.auto_approve, ...renamePreviews.review];

    if (itemsToRename.length === 0) {
        addScanLog('No files to rename', 'error');
        return;
    }

    const dryRunBtn = document.getElementById('executeDryRunBtn');
    const renameBtn = document.getElementById('executeRenameBtn');
    const progressContainer = document.getElementById('renameProgressContainer');
    const progressText = document.getElementById('renameProgressText');
    const progressBar = document.getElementById('renameProgressBar');
    const resultsContainer = document.getElementById('renameResultsContainer');

    // Disable buttons and show progress
    dryRunBtn.disabled = true;
    renameBtn.disabled = true;
    progressContainer.style.display = 'block';
    resultsContainer.style.display = 'none';

    // Get cleanup option from checkbox
    const cleanupEmptyDirs = document.getElementById('cleanupEmptyDirsCheckbox')?.checked ?? true;

    try {
        const eventSource = await fetch('http://localhost:3000/api/matcher/execute-rename', {
            method: 'POST',
            headers: { 'Content-Type': 'application/json' },
            body: JSON.stringify({
                renameItems: itemsToRename,
                dryRun: dryRun,
                cleanupEmptyDirs: cleanupEmptyDirs
            })
        });

        const reader = eventSource.body.getReader();
        const decoder = new TextDecoder();

        while (true) {
            const { done, value } = await reader.read();
            if (done) break;

            const chunk = decoder.decode(value);
            const lines = chunk.split('\n');

            for (const line of lines) {
                if (line.startsWith('data: ')) {
                    try {
                        const data = JSON.parse(line.slice(6));

                        if (data.type === 'progress') {
                            progressText.textContent = `${dryRun ? '[DRY RUN] ' : ''}Processing ${data.currentFile || ''}... (${data.processed}/${data.total})`;
                            progressBar.style.width = `${data.progress}%`;
                        } else if (data.type === 'complete') {
                            console.log('[Matcher] Rename complete:', data);

                            progressText.textContent = data.message;
                            progressBar.style.width = '100%';

                            // Display results
                            displayRenameResults(data.results, dryRun);
                            resultsContainer.style.display = 'block';

                            addScanLog(data.message, 'success');

                            // Initialize Phase 4 after successful rename (not dry-run)
                            if (!dryRun && data.results && data.results.length > 0) {
                                initMoveToLibrary();
                            }
                        } else if (data.type === 'error') {
                            progressText.textContent = `Error: ${data.error}`;
                            addScanLog(`Rename error: ${data.error}`, 'error');
                        }
                    } catch (parseError) {
                        console.error('[Matcher] Parse error:', parseError);
                    }
                }
            }
        }
    } catch (error) {
        console.error('[Matcher] Rename error:', error);
        progressText.textContent = `Error: ${error.message}`;
        addScanLog(`Rename error: ${error.message}`, 'error');
    } finally {
        dryRunBtn.disabled = false;
        renameBtn.disabled = false;
    }
}

/**
 * Display rename execution results
 */
function displayRenameResults(results, dryRun) {
    const resultsList = document.getElementById('renameResultsList');

    if (!results || results.length === 0) {
        resultsList.innerHTML = '<div class="no-results">No results to display</div>';
        return;
    }

    let html = '';

    for (const result of results) {
        const statusClass = result.status.includes('success') ? 'success' : result.status === 'error' ? 'error' : 'skipped';
        const icon = statusClass === 'success' ? '✅' : statusClass === 'error' ? '❌' : '⏭️';

        html += `
            <div class="rename-result-item ${statusClass}">
                <span>${icon}</span>
                <span>${result.message || result.status}</span>
            </div>
        `;
    }

    resultsList.innerHTML = html;
}

/**
 * ================================================================================
 * MOVE TO LIVE PLEX LIBRARY (Phase 4)
 * ================================================================================
 */

// Phase 4 state
let movePlan = null;
let moveResults = null;

/**
 * Initialize Move to Live Library section after rename is complete
 */
function initMoveToLibrary() {
    console.log('[Move] Initializing Move to Live Library...');

    const moveSection = document.getElementById('moveToLibrarySection');
    const validatePathBtn = document.getElementById('validatePathBtn');
    const planMoveBtn = document.getElementById('planMoveBtn');
    const executeMoveBtn = document.getElementById('executeMoveBtn');
    const cancelPlanBtn = document.getElementById('cancelPlanBtn');
    const rollbackMoveBtn = document.getElementById('rollbackMoveBtn');
    const triggerPlexRefreshBtn = document.getElementById('triggerPlexRefreshBtn');
    const newMoveBtn = document.getElementById('newMoveBtn');
    const liveLibraryPathInput = document.getElementById('liveLibraryPath');

    // Show move section after rename completes
    if (moveSection && renamePreviews) {
        moveSection.style.display = 'block';
        addScanLog('Move to Live Library ready - scroll down to configure', 'info');
    }

    // Load saved live library path
    const savedLiveLibPath = localStorage.getItem('liveLibraryPath');
    if (savedLiveLibPath && liveLibraryPathInput) {
        liveLibraryPathInput.value = savedLiveLibPath;
    }

    // Setup event listeners
    if (validatePathBtn) {
        validatePathBtn.addEventListener('click', handleValidatePath);
    }

    if (planMoveBtn) {
        planMoveBtn.addEventListener('click', handlePlanMove);
    }

    if (executeMoveBtn) {
        executeMoveBtn.addEventListener('click', handleExecuteMove);
    }

    if (cancelPlanBtn) {
        cancelPlanBtn.addEventListener('click', handleCancelPlan);
    }

    if (rollbackMoveBtn) {
        rollbackMoveBtn.addEventListener('click', handleRollback);
    }

    if (triggerPlexRefreshBtn) {
        triggerPlexRefreshBtn.addEventListener('click', handleTriggerPlexRefresh);
    }

    if (newMoveBtn) {
        newMoveBtn.addEventListener('click', resetMoveSection);
    }

    // Add drag and drop support for live library path
    setupLiveLibraryDragAndDrop();
}

/**
 * Setup drag and drop for live library path input
 */
function setupLiveLibraryDragAndDrop() {
    const input = document.getElementById('liveLibraryPath');
    if (!input) return;

    // Prevent default drag behaviors
    ['dragenter', 'dragover', 'dragleave', 'drop'].forEach(eventName => {
        input.addEventListener(eventName, preventDefaults, false);
    });

    function preventDefaults(e) {
        e.preventDefault();
        e.stopPropagation();
    }

    // Highlight input when item is dragged over it
    ['dragenter', 'dragover'].forEach(eventName => {
        input.addEventListener(eventName, () => {
            input.style.borderColor = '#667eea';
            input.style.backgroundColor = '#f0f4ff';
        }, false);
    });

    ['dragleave', 'drop'].forEach(eventName => {
        input.addEventListener(eventName, () => {
            input.style.borderColor = '#e1e8ed';
            input.style.backgroundColor = 'white';
        }, false);
    });

    // Handle dropped files/folders
    input.addEventListener('drop', (e) => {
        const dt = e.dataTransfer;
        const items = dt.items;

        if (items) {
            for (let i = 0; i < items.length; i++) {
                const item = items[i];
                if (item.kind === 'file') {
                    const entry = item.webkitGetAsEntry();
                    if (entry && entry.isDirectory) {
                        const folderName = entry.name;
                        const fullPath = prompt(
                            `You dropped the folder: "${folderName}"\n\n` +
                            `Please enter the FULL path to this folder:\n` +
                            `(e.g., /Users/yourname/Music/${folderName} or C:\\Users\\yourname\\Music\\${folderName})`,
                            ''
                        );

                        if (fullPath) {
                            input.value = fullPath;
                            localStorage.setItem('liveLibraryPath', fullPath);
                        }
                        break;
                    }
                }
            }
        }
    }, false);
}

/**
 * Handle path validation
 */
async function handleValidatePath() {
    const liveLibraryPath = document.getElementById('liveLibraryPath').value.trim();
    const statusEl = document.getElementById('pathValidationStatus');

    if (!liveLibraryPath) {
        showPathValidationStatus('error', 'Please enter a live library path');
        return;
    }

    // Save to localStorage
    localStorage.setItem('liveLibraryPath', liveLibraryPath);

    statusEl.style.display = 'block';
    statusEl.className = 'connection-status info';
    statusEl.textContent = 'Validating path...';

    try {
        const response = await fetch('http://localhost:3000/api/organizer/validate-path', {
            method: 'POST',
            headers: { 'Content-Type': 'application/json' },
            body: JSON.stringify({ path: liveLibraryPath })
        });

        const result = await response.json();

        if (result.success && result.writable) {
            showPathValidationStatus('success', '✓ Path is valid and writable');
            addScanLog(`Live library path validated: ${liveLibraryPath}`, 'success');
        } else if (result.success && !result.writable) {
            showPathValidationStatus('error', '⚠ Path exists but is not writable');
            addScanLog(`Live library path is not writable: ${liveLibraryPath}`, 'error');
        } else {
            showPathValidationStatus('error', `✗ ${result.error || 'Path validation failed'}`);
            addScanLog(`Path validation failed: ${result.error}`, 'error');
        }
    } catch (error) {
        showPathValidationStatus('error', `Error: ${error.message}`);
        addScanLog(`Path validation error: ${error.message}`, 'error');
    }
}

/**
 * Show path validation status
 */
function showPathValidationStatus(type, message) {
    const statusEl = document.getElementById('pathValidationStatus');
    statusEl.style.display = 'block';
    statusEl.className = `connection-status ${type}`;
    statusEl.textContent = message;
}

/**
 * Handle plan move (dry-run)
 */
async function handlePlanMove() {
    const liveLibraryPath = document.getElementById('liveLibraryPath').value.trim();
    const moveMode = document.querySelector('input[name="moveMode"]:checked').value;

    if (!liveLibraryPath) {
        showPathValidationStatus('error', 'Please enter a live library path');
        return;
    }

    // Use all scanned files, not just renamed files
    if (!scanData || !scanData.files || scanData.files.length === 0) {
        addScanLog('No scanned files to move. Please complete a deep scan first.', 'error');
        return;
    }

    const planBtn = document.getElementById('planMoveBtn');
    planBtn.disabled = true;
    planBtn.textContent = 'Planning...';

    try {
        // Use all scanned files from the deep scan
        const filesToMove = scanData.files;

        const response = await fetch('http://localhost:3000/api/organizer/plan-move', {
            method: 'POST',
            headers: { 'Content-Type': 'application/json' },
            body: JSON.stringify({
                files: filesToMove,
                liveLibraryPath,
                plexTracks: plexTracks || null,
                mode: moveMode
            })
        });

        const result = await response.json();

        if (result.success) {
            movePlan = result.plan;
            displayMovePlan(movePlan);
            document.getElementById('movePlanContainer').style.display = 'block';
            addScanLog(`Move plan generated: ${movePlan.summary.newFiles + movePlan.summary.upgrades} files will be moved`, 'success');
        } else {
            addScanLog(`Plan error: ${result.error}`, 'error');
        }
    } catch (error) {
        addScanLog(`Plan error: ${error.message}`, 'error');
    } finally {
        planBtn.disabled = false;
        planBtn.textContent = '🔍 Plan Move (Dry-Run)';
    }
}

/**
 * Display move plan preview
 */
function displayMovePlan(plan) {
    // Update summary statistics
    document.getElementById('planStatNewFiles').textContent = plan.summary.newFiles;
    document.getElementById('planStatUpgrades').textContent = plan.summary.upgrades;
    document.getElementById('planStatDowngrades').textContent = plan.summary.downgrades;
    document.getElementById('planStatSameQuality').textContent = plan.summary.sameQuality;

    // Display operations to be performed
    const planList = document.getElementById('movePlanList');
    let html = '';

    // Show new files
    for (const op of plan.newFiles.slice(0, 20)) {
        html += `
            <div class="rename-preview-item">
                <div class="rename-preview-path original">
                    <strong>Source:</strong> ${op.sourcePath}
                </div>
                <div class="rename-preview-arrow">↓ ADD</div>
                <div class="rename-preview-path proposed">
                    <strong>Destination:</strong> ${op.destinationPath}
                </div>
            </div>
        `;
    }

    // Show upgrades
    for (const op of plan.upgrades.slice(0, 20)) {
        html += `
            <div class="rename-preview-item">
                <div class="rename-preview-path original">
                    <strong>Source:</strong> ${op.sourcePath}
                </div>
                <div class="rename-preview-arrow">↓ REPLACE (Quality Upgrade)</div>
                <div class="rename-preview-path proposed">
                    <strong>Destination:</strong> ${op.destinationPath}
                </div>
            </div>
        `;
    }

    // Show downgrades (will be skipped)
    for (const op of plan.downgrades.slice(0, 10)) {
        html += `
            <div class="rename-preview-item" style="opacity: 0.6;">
                <div class="rename-preview-path original">
                    <strong>Source:</strong> ${op.sourcePath}
                </div>
                <div class="rename-preview-arrow">⏭️ SKIP (Quality Downgrade)</div>
                <div class="rename-preview-path proposed">
                    <strong>Reason:</strong> ${op.reason}
                </div>
            </div>
        `;
    }

    const totalShown = Math.min(20, plan.newFiles.length + plan.upgrades.length) + Math.min(10, plan.downgrades.length);
    const totalOperations = plan.newFiles.length + plan.upgrades.length + plan.downgrades.length + plan.sameQuality.length;

    if (totalOperations > totalShown) {
        html += `<div class="no-results">... and ${totalOperations - totalShown} more operations</div>`;
    }

    planList.innerHTML = html;
}

/**
 * Handle execute move
 */
async function handleExecuteMove() {
    if (!movePlan) {
        addScanLog('No move plan available. Please click "Plan Move" first.', 'error');
        return;
    }

    const confirmed = confirm(
        `You are about to move ${movePlan.summary.newFiles + movePlan.summary.upgrades} files to your live Plex library.\n\n` +
        `This operation will:\n` +
        `- Add ${movePlan.summary.newFiles} new files\n` +
        `- Replace ${movePlan.summary.upgrades} files with higher quality versions\n` +
        `- Skip ${movePlan.summary.downgrades + movePlan.summary.sameQuality} duplicates/downgrades\n\n` +
        `Do you want to proceed?`
    );

    if (!confirmed) return;

    const executeBtn = document.getElementById('executeMoveBtn');
    const progressContainer = document.getElementById('moveProgressContainer');
    const progressText = document.getElementById('moveProgressText');
    const progressBar = document.getElementById('moveProgressBar');
    const resultsContainer = document.getElementById('moveResultsContainer');

    executeBtn.disabled = true;
    progressContainer.style.display = 'block';
    resultsContainer.style.display = 'none';

    // Combine operations to execute (new files + upgrades)
    const operationsToExecute = [...movePlan.newFiles, ...movePlan.upgrades];

    try {
        const response = await fetch('http://localhost:3000/api/organizer/execute-move', {
            method: 'POST',
            headers: { 'Content-Type': 'application/json' },
            body: JSON.stringify({
                operations: operationsToExecute,
                dryRun: false,
                cleanupEmptyDirs: true
            })
        });

        const reader = response.body.getReader();
        const decoder = new TextDecoder();

        while (true) {
            const { done, value } = await reader.read();
            if (done) break;

            const chunk = decoder.decode(value);
            const lines = chunk.split('\n');

            for (const line of lines) {
                if (line.startsWith('data: ')) {
                    try {
                        const data = JSON.parse(line.slice(6));

                        if (data.type === 'progress') {
                            progressText.textContent = `Moving ${data.currentFile || ''}... (${data.processed}/${data.total})`;
                            progressBar.style.width = `${data.progress}%`;
                        } else if (data.type === 'complete') {
                            console.log('[Move] Move complete:', data);
                            moveResults = data.results;

                            progressText.textContent = data.message;
                            progressBar.style.width = '100%';

                            // Display results
                            displayMoveResults(data.results);
                            resultsContainer.style.display = 'block';

                            addScanLog(data.message, 'success');
                        } else if (data.type === 'error') {
                            progressText.textContent = `Error: ${data.error}`;
                            addScanLog(`Move error: ${data.error}`, 'error');
                        }
                    } catch (parseError) {
                        console.error('[Move] Parse error:', parseError);
                    }
                }
            }
        }
    } catch (error) {
        console.error('[Move] Move error:', error);
        progressText.textContent = `Error: ${error.message}`;
        addScanLog(`Move error: ${error.message}`, 'error');
    } finally {
        executeBtn.disabled = false;
    }
}

/**
 * Display move results
 */
function displayMoveResults(results) {
    const resultsList = document.getElementById('moveResultsList');

    if (!results || results.length === 0) {
        resultsList.innerHTML = '<div class="no-results">No results to display</div>';
        return;
    }

    let html = '';

    for (const result of results) {
        const statusClass = result.status.includes('success') ? 'success' : result.status === 'error' ? 'error' : 'skipped';
        const icon = statusClass === 'success' ? '✅' : statusClass === 'error' ? '❌' : '⏭️';

        const actionText = result.action === 'REPLACE' ? 'Replaced (upgrade)' : result.action || result.status;

        html += `
            <div class="rename-result-item ${statusClass}">
                <span>${icon}</span>
                <span><strong>${actionText}:</strong> ${result.destinationPath || result.sourcePath}</span>
            </div>
        `;
    }

    resultsList.innerHTML = html;
}

/**
 * Handle cancel plan
 */
function handleCancelPlan() {
    movePlan = null;
    document.getElementById('movePlanContainer').style.display = 'none';
    addScanLog('Move plan cancelled', 'info');
}

/**
 * Handle rollback
 */
async function handleRollback() {
    const confirmed = confirm(
        'This will attempt to undo the last move operation.\n\n' +
        'Note: Deleted files (from quality upgrades) cannot be restored.\n\n' +
        'Do you want to proceed?'
    );

    if (!confirmed) return;

    const rollbackBtn = document.getElementById('rollbackMoveBtn');
    rollbackBtn.disabled = true;
    rollbackBtn.textContent = 'Rolling back...';

    try {
        const response = await fetch('http://localhost:3000/api/organizer/rollback', {
            method: 'POST',
            headers: { 'Content-Type': 'application/json' }
        });

        const result = await response.json();

        if (result.success) {
            addScanLog(`Rollback complete: ${result.summary.restored} files restored, ${result.summary.deleted} files deleted`, 'success');
            alert(`Rollback completed.\n\nRestored: ${result.summary.restored}\nDeleted: ${result.summary.deleted}\nFailed: ${result.summary.failed}`);
        } else {
            addScanLog(`Rollback error: ${result.error}`, 'error');
        }
    } catch (error) {
        addScanLog(`Rollback error: ${error.message}`, 'error');
    } finally {
        rollbackBtn.disabled = false;
        rollbackBtn.textContent = '↩️ Rollback Last Move';
    }
}

/**
 * Handle trigger Plex refresh
 */
async function handleTriggerPlexRefresh() {
    if (!plexConnectionData || !selectedLibraryId) {
        addScanLog('Plex connection data not available. Please complete Phase 2.5 first.', 'error');
        return;
    }

    const { serverIp, port, token } = plexConnectionData;
    const refreshBtn = document.getElementById('triggerPlexRefreshBtn');
    refreshBtn.disabled = true;
    refreshBtn.textContent = 'Refreshing...';

    try {
        const response = await fetch('http://localhost:3000/api/organizer/plex-refresh', {
            method: 'POST',
            headers: { 'Content-Type': 'application/json' },
            body: JSON.stringify({ serverIp, port, token, libraryId: selectedLibraryId })
        });

        const result = await response.json();

        if (result.success) {
            addScanLog('Plex library refresh triggered successfully', 'success');
            alert('Plex library refresh triggered! Your Plex server will now scan for new files.');
        } else {
            addScanLog(`Plex refresh error: ${result.message}`, 'error');
        }
    } catch (error) {
        addScanLog(`Plex refresh error: ${error.message}`, 'error');
    } finally {
        refreshBtn.disabled = false;
        refreshBtn.textContent = '🔄 Trigger Plex Refresh';
    }
}

/**
 * Reset move section for new operation
 */
function resetMoveSection() {
    movePlan = null;
    moveResults = null;
    document.getElementById('movePlanContainer').style.display = 'none';
    document.getElementById('moveProgressContainer').style.display = 'none';
    document.getElementById('moveResultsContainer').style.display = 'none';
    document.getElementById('pathValidationStatus').style.display = 'none';
    addScanLog('Move section reset', 'info');
}

// Register the organizer route
router.register('organizer', initOrganizer);
